<!--
     The FreeBSD Documentation Project

     $FreeBSD: doc/zh/big5/handbook/disks/chapter.sgml,v 1.8 2003/01/29 06:32:47 statue Exp $

     Translate into Chinese by tsaimh@csie.nctu.edu.tw
                                yckuo@yes.net.tw
                                huangant@ms10.hinet.net
     English Version: 1.140
-->

<chapter id="disks">
  <title>Storage</title>

  <sect1 id="disks-synopsis">
    <title>Synopsis</title>


    <para>This chapter covers the use of disks in FreeBSD.  This
      includes memory-backed disks, network-attached disks, and
      standard SCSI/IDE storage devices.</para>

    <para>After reading this chapter, you will know:</para>
    <itemizedlist>
      <listitem><para>The terminology FreeBSD uses to describe the
      organization of data on a physical disk (partitions and slices).</para>
      </listitem>
      <listitem><para>How to mount and unmount file systems.</para>
      </listitem>
      <listitem><para>How to add additional hard disks to your system.</para>
      </listitem>
      <listitem><para>How to setup virtual file systems, such as memory
      disks.</para></listitem>
      <listitem>
	<para>How to use quotas to limit disk space usage.</para>
      </listitem>
      <listitem>
	<para>How to create and burn CDs and DVDs on FreeBSD.</para>
      </listitem>
      <listitem>
        <para>The various storage media options for backups.</para>
      </listitem>
      <listitem>
        <para>How to use backup programs available under FreeBSD.</para>
      </listitem>
      <listitem>
        <para>How to backup to floppy disks.</para>
      </listitem>
      <listitem>
        <para>What snapshots are and how to use them efficiently.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="disks-naming">
    <title>Device Names</title>

    <para>The following is a list of physical storage devices
      supported in FreeBSD, and the device names associated with
      them.</para>

    <table id="disk-naming-physical-table">
      <title>Physical Disk Naming Conventions</title>

      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Drive type</entry>
	    <entry>Drive device name</entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry>IDE hard drives</entry>
	    <entry><literal>ad</literal></entry>
	  </row>
	  <row>
	    <entry>IDE CDROM drives</entry>
	    <entry><literal>acd</literal></entry>
	  </row>
	  <row>
	    <entry>SCSI hard drives and USB Mass storage devices</entry>
	    <entry><literal>da</literal></entry>
	  </row>
	  <row>
	    <entry>SCSI CDROM drives</entry>
	    <entry><literal>cd</literal></entry>
	  </row>
	  <row>
	    <entry>Assorted non-standard CDROM drives</entry>
	    <entry><literal>mcd</literal> for Mitsumi CD-ROM,
	      <literal>scd</literal> for Sony CD-ROM,
	      <literal>matcd</literal> for Matsushita/Panasonic CD-ROM
		<footnote>
		  <para>The &man.matcd.4; driver has been removed
		    in FreeBSD&nbsp;4.X branch since October 5th,
		    2002 and does not exist in FreeBSD&nbsp;5.0 and
		    later.</para>
		</footnote>
	    </entry>
	  </row>
	  <row>
	    <entry>Floppy drives</entry>
	    <entry><literal>fd</literal></entry>
	  </row>
	  <row>
	    <entry>SCSI tape drives</entry>
	    <entry><literal>sa</literal></entry>
            </row>
	  <row>
	    <entry>IDE tape drives</entry>
	    <entry><literal>ast</literal></entry>
	  </row>
	  <row>
	    <entry>Flash drives</entry>
	    <entry><literal>fla</literal> for DiskOnChip Flash device</entry>
	  </row>
	  <row>
	    <entry>RAID drives</entry>
	    <entry><literal>aacd</literal> for Adaptec AdvancedRAID,
	      <literal>mlxd</literal> and <literal>mlyd</literal>
	      for Mylex,
	      <literal>amrd</literal> for AMI MegaRAID,
	      <literal>idad</literal> for Compaq Smart RAID,
	      <literal>twed</literal> for 3Ware RAID.</entry>
	  </row>
	</tbody>
      </tgroup>
    </table>
  </sect1>
    
  <sect1 id="disks-adding">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>David</firstname>
	  <surname>O'Brien</surname>
	  <contrib>Originally contributed by </contrib>
	</author>
      </authorgroup>
      <!-- 26 Apr 1998 -->
    </sect1info>

    <title>Adding Disks</title>

    <indexterm>
      <primary>disks</primary>
      <secondary>adding</secondary>
    </indexterm>

    <para>我們以 SCSI 硬碟為例，討論如何在 FreeBSD 上安裝一台新的磁碟機
      （假設這台機器目前只有一台磁碟機）。按照說明書的指示，將磁碟機安裝
     妥當（由於安裝過程太過繁雜，故其細節不在本文件中討論）。</para>

    <para>以 <username>root</username>的身份登入系統，檢查
      <filename>/var/run/dmesg.boot</filename>，
      確認系統是否有找到這台新的磁碟機。在我們的例子裡，新磁碟機的
      device node 為 <filename>da1</filename>，而我們要將這台磁碟機 mount
      到 <filename>/1</filename>（如果是 IDE 的磁碟機，在 4.0 之前的系統是
      <filename>wd1</filename>，而在 4.X 的系統中是 <filename>ad1</filename>
      )。</para>

    <indexterm><primary>partitions</primary></indexterm>
    <indexterm><primary>slices</primary></indexterm>
    <indexterm>
      <primary><command>fdisk</command></primary>
    </indexterm>

    <para>由於 FreeBSD 是安裝在與 IBM PC 相容的電腦上，所以必須討論到
      PC BIOS partition。不同於傳統的 BSD partition，PC
      上的磁碟最多可以有 4 個 BIOS partition entry。我們可以將<emphasis>
      整顆硬碟</emphasis>指定給 FreeBSD，也可以將 FreeBSD 裝在某一個 PC BIOS
      partition 上。FreeBSD 把 PC BIOS partition 稱作
      <emphasis>slices</emphasis>  ，以避免與傳統 BSD partition
      混淆。我們可以將安裝有其他作業系統的 slice 指定給
      FreeBSD ，同時不會使原作業系統的 <command>fdisk</command>
      工具發生問題。</para>

    <para>以 slice 的方式來安裝 FreeBSD ,這台新的磁碟機為
      <filename>/dev/da1s1e</filename>，意思是 SCSI 磁碟，編號 1
      （意指第二顆 SCSI 磁碟），slice 1 （即 PC BIOS partition 1），BSD
      partition <filename>e</filename> 。若將整顆磁碟指定給 FreeBSD
      ，則為 <filename>/dev/da1e</filename>。</para>

    <sect2>
      <title>使用 &man.sysinstall.8;</title>
      <indexterm>
        <primary><application>sysinstall</application></primary>
        <secondary>adding disks</secondary>
      </indexterm>
      <indexterm>
	<primary>su</primary>
      </indexterm>
      <procedure>
	<step>
	  <title>Navigating <application>Sysinstall</application></title>

      <para>您可以使用 <command>/stand/sysinstall</command> 中的選單功
        能來分割一顆新的磁碟。以 <username>root</username> 的身份
        login 或利用 <command>su</command> 指令來執行
        <command>/stand/sysinstall</command> ，選
        <literal>Configure</literal> ，進入 <literal>FreeBSD
        Configuration Menu</literal>選單，選擇
        <literal>Partition</literal> 這個選項，您將會看到一份硬碟清單
        ，假如您沒看到 <literal>da1</literal> ，
        您可能必須檢查一下您的硬碟是否正確安裝到主機，並利用
        <command>dmesg</command> 列出並檢查
        <filename>/var/run/dmesg.boot</filename>這個檔。</para>
	</step>

	<step>
	  <title><application>fdisk</application> Partition Editor</title>
      <para>進入 <literal>FDISK Partition
        Editor</literal>，假設要把整顆磁碟都給 FreeBSD 使用，選
        <literal>A</literal> 。當問到 <quote>remain cooperative with
        any future possible operating systems</quote> 時，回答
        <literal>YES</literal>，接著就按 <command>W</command> 儲存，
        <command>q</command> 離開。接下來您會被問到關於 Master Boot
        Record 的問題，因為您是安裝一顆磁碟到一個現成的作業系統上，
        所以選 <literal>None</literal>。</para>
	</step>

	<step>
	  <title>Disk Label Editor</title>
	  <indexterm><primary>BSD partitions</primary></indexterm>

	  <para>Next, you need to exit <application>sysinstall</application>
            and start it again.  Follow the directions above, although this
            time choose the <literal>Label</literal> option. This will
	    enter the <literal>Disk Label Editor</literal>.  This
	    is where you will create the traditional BSD partitions.  
        一顆磁碟最多可以擁有 8 個 partition
        ，依次是 a 到 h 。某些 partition 有特殊的意義 :
        partition <literal>a</literal> 是指 <filename>/</filename>
        (root partition)，只有您的開機磁碟可以擁有 partition
        <literal>a</literal> ，partition <literal>b</literal> 是指
        swap partition ，您可以同時擁有數個具有 swap partition 的磁碟，
        partition <literal>c</literal> 是指整顆磁碟，
        其他的都可以任意使用。</para>

      <para>sysinstall 的 Label editor 喜歡用 <literal>e</literal> 作為非
        root，非 swap 的 partition，按 <command>C</command>
        建立一個獨立的檔案系統，接著會問您說這是 FS(file system)或 swap，
        選擇<literal>FS</literal> ，然後指定一個 mount point (例如
        <filename>/mnt</filename>)。在 post-install 模式下新增的磁碟，
        sysinstall 並不會幫您加入到 <filename>/etc/fstab</filename> 下，
        這時 mount point並不重要。</para>

	  <para>You are now ready to write the new label to the disk and
	    create a file system on it.  
        按下 <command>W</command> 鍵，將新的 label 寫到磁碟上,並在
        磁碟上建立一個檔案系統，忽略所有跟新的 partition 無關的錯誤訊息
        ，然後離開 Label Editor 及 sysinstall。</para>
	</step>

	<step>
	  <title>Finish</title>

      <para>最後，只要編輯 <filename>/etc/fstab</filename> ，把新磁碟加上就
        OK 了。</para>
	</step>
      </procedure>
    </sect2>

    <sect2>
      <title>使用命令列的工具程式</title>

      <sect3>
	<title>Using Slices</title>

	<para>This setup will allow your disk to work correctly with
	  other operating systems that might be installed on your
	  computer and will not confuse other operating systems' 
	  <command>fdisk</command> utilities.  It is recommended 
	  to use this method for new disk installs.  Only use 
	  <literal>dedicated</literal> mode if you have a good reason 
	  to do so!</para>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/da1 bs=1k count=1</userinput>
&prompt.root; <userinput>fdisk -BI da1</userinput> #Initialize your new disk
&prompt.root; <userinput>disklabel -B -w -r da1s1 auto</userinput> #Label it.
&prompt.root; <userinput>disklabel -e da1s1</userinput> # Edit the disklabel just created and add any partitions.
&prompt.root; <userinput>mkdir -p /1</userinput>
&prompt.root; <userinput>newfs /dev/da1s1e</userinput> # Repeat this for every partition you created.
&prompt.root; <userinput>mount /dev/da1s1e /1</userinput> # Mount the partition(s)
&prompt.root; <userinput>vi /etc/fstab</userinput> # Add the appropriate entry/entries to your <filename>/etc/fstab</filename>.</screen>

	<para>If you have an IDE disk, substitute <filename>ad</filename>
	  for <filename>da</filename>.  On pre-4.X systems use
	  <filename>wd</filename>.</para> 
      </sect3>
      
      <sect3>
	<title>Dedicated</title>
	<indexterm><primary>OS/2</primary></indexterm>

        <para>假如您不打算和其他的作業系統共用新的磁碟，您可以使用
          <literal>dedicated</literal> 模式，要記得的是，這種模式會使
          Microsoft 的作業系統產生混淆，但不致於造成損壞；而 IBM 的 OS/2
          則會<quote>佔用</quote>所有它不認識的 partition 。</para>
	
	<screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/da1 bs=1k count=1</userinput>
&prompt.root; <userinput>disklabel -Brw da1 auto</userinput>
&prompt.root; <userinput>disklabel -e da1</userinput>				# create the `e' partition
&prompt.root; <userinput>newfs -d0 /dev/da1e</userinput>
&prompt.root; <userinput>mkdir -p /1</userinput>
&prompt.root; <userinput>vi /etc/fstab</userinput>				# add an entry for /dev/da1e
&prompt.root; <userinput>mount /1</userinput></screen>
      
	<para>另一個替代的方法：</para>
      
	<screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/da1 count=2</userinput>
&prompt.root; <userinput>disklabel /dev/da1 | disklabel -BrR da1 /dev/stdin</userinput>
&prompt.root; <userinput>newfs /dev/da1e</userinput>
&prompt.root; <userinput>mkdir -p /1</userinput>
&prompt.root; <userinput>vi /etc/fstab</userinput>					# add an entry for /dev/da1e
&prompt.root; <userinput>mount /1</userinput></screen>
      </sect3>
    </sect2>
  </sect1>
  
  <sect1 id="raid">
    <title>RAID</title>

    <sect2 id="raid-soft">
      <title>Software RAID</title>

      <sect3 id="ccd">
	<sect3info>
	  <authorgroup>
	    <author>
	      <firstname>Christopher</firstname>
	      <surname>Shumway</surname>
	      <contrib>Written by </contrib>
	    </author>
	  </authorgroup>
	  <authorgroup>
	    <author>
	      <firstname>Valentino</firstname>
	      <surname>Vaschetto</surname>
	      <contrib>Marked up by </contrib>
	    </author>
	  </authorgroup>
	</sect3info>

	<title>ccd (Concatenated Disk Configuration)</title>
	<para>When choosing a mass storage solution the most important
	  factors to consider are speed, reliability, and cost.  It is very
	  rare to have all three in favor; normally a fast, reliable mass
	  storage device is expensive, and to cut back on cost either speed
	  or reliability must be sacrificed.  In designing my system, I
	  ranked the requirements by most favorable to least favorable.  In
	  this situation, cost was the biggest factor.  I needed a lot of
	  storage for a reasonable price.  The next factor, speed, is not
	  quite as important, since most of the usage would be over a one
	  hundred megabit switched Ethernet, and that would most likely be
	  the bottleneck.  The ability to spread the file input/output
	  operations out over several disks would be more than enough speed
	  for this network.  Finally, the consideration of reliability was
	  an easy one to answer.  All of the data being put on this mass
	  storage device was already backed up on CD-R's.  This drive was
	  primarily here for online live storage for easy access, so if a
	  drive went bad, I could just replace it, rebuild the file system,
	  and copy back the data from CD-R's.</para>

	<para>To sum it up, I need something that will give me the most
	  amount of storage space for my money.  The cost of large IDE disks
	  are cheap these days.  I found a place that was selling Western
	  Digital 30.7GB 5400 RPM IDE disks for about one-hundred and thirty
	  US dollars.  I bought three of them, giving me approximately
	  ninety gigabytes of online storage.</para>

	<sect4 id="ccd-installhw">
	  <title>Installing the Hardware</title>

	  <para>I installed the hard drives in a system that already
	    had one IDE disk in as the system disk.  The ideal solution
	    would be for each IDE disk to have its own IDE controller
	    and cable, but without fronting more costs to acquire a dual
	    IDE controller this would not be a possibility.  So, I
	    jumpered two disks as slaves, and one as master.  One went
	    on the first IDE controller as a slave to the system disk,
	    and the other two where slave/master on the secondary IDE
	    controller.</para>

	  <para>Upon reboot, the system BIOS was configured to
	    automatically detect the disks attached.  More importantly,
	    FreeBSD detected them on reboot:</para>

	  <programlisting>ad0: 19574MB &lt;WDC WD205BA&gt; [39770/16/63] at ata0-master UDMA33
ad1: 29333MB &lt;WDC WD307AA&gt; [59598/16/63] at ata0-slave UDMA33
ad2: 29333MB &lt;WDC WD307AA&gt; [59598/16/63] at ata1-master UDMA33
ad3: 29333MB &lt;WDC WD307AA&gt; [59598/16/63] at ata1-slave UDMA33</programlisting>

	  <para>At this point, if FreeBSD does not detect the disks, be
	    sure that you have jumpered them correctly.  I have heard
	    numerous reports with problems using cable select instead of
	    true slave/master configuration.</para>

	  <para>The next consideration was how to attach them as part of
	    the file system.  I did a little research on &man.vinum.8;
	      (<xref linkend="vinum-vinum">) and
	      &man.ccd.4;.  In this particular configuration, &man.ccd.4;
	    appeared to be a better choice mainly because it has fewer
	    parts.  Less parts tends to indicate less chance of breakage.
	    Vinum appears to be a bit of an overkill for my needs.</para>
	</sect4>

	<sect4 id="ccd-setup">
	  <title>Setting up the CCD</title>

	  <para><application>CCD</application> allows me to take
	    several identical disks and concatenate them into one
	    logical file system.  In order to use
	    <application>ccd</application>, I need a kernel with
	    <application>ccd</application> support built into it.  I
	    added this line to my kernel configuration file and rebuilt
	    the kernel:</para>

	  <programlisting>pseudo-device   ccd     4</programlisting>

	  <note><para>In FreeBSD 5.0, it is not necessary to specify
	    a number of ccd devices, as the ccd device driver is now
	    cloning -- new device instances will automatically be
	    created on demand.</para></note>

	  <para><application>ccd</application> support can also be
	    loaded as a kernel loadable module in FreeBSD 4.0 or
	    later.</para>

	  <para>To set up <application>ccd</application>, first I need
	    to disklabel the disks.  Here is how I disklabeled
	    them:</para>

	  <programlisting>disklabel -r -w ad1 auto
disklabel -r -w ad2 auto
disklabel -r -w ad3 auto</programlisting>

	  <para>This created a disklabel ad1c, ad2c and ad3c that
	    spans the entire disk.</para>

	  <para>The next step is to change the disklabel type.  To do
	    that I had to edit the disklabel:</para>

	  <programlisting>disklabel -e ad1
disklabel -e ad2
disklabel -e ad3</programlisting>

	  <para>This opened up the current disklabel on each disk
	    respectively in whatever editor the <envar>EDITOR</envar>
	    environment variable was set to, in my case, &man.vi.1;.
	    Inside the editor I had a section like this:</para>

	  <programlisting>8 partitions:
#        size   offset    fstype   [fsize bsize bps/cpg]
  c: 60074784        0    unused        0     0     0   # (Cyl.    0 - 59597)</programlisting>

	  <para>I needed to add a new "e" partition for &man.ccd.4; to
	    use. This usually can be copied of the "c" partition, but
	    the <option>fstype</option> must be <userinput>4.2BSD</userinput>.
	    Once I was done,
	    my disklabel should look like this:</para>

	  <programlisting>8 partitions:
#        size   offset    fstype   [fsize bsize bps/cpg]
  c: 60074784        0    unused        0     0     0   # (Cyl.    0 - 59597)
  e: 60074784        0    4.2BSD        0     0     0   # (Cyl.    0 - 59597)</programlisting>

	</sect4>

	<sect4 id="ccd-buildingfs">
	  <title>Building the File System</title>

	  <para>Now that I have all of the disks labeled, I needed to
	    build the <application>ccd</application>.  To do that, I
	    used a utility called &man.ccdconfig.8;.
	    <command>ccdconfig</command> takes several arguments, the
	    first argument being the device to configure, in this case,
	    <devicename>/dev/ccd0c</devicename>.  The device node for
	    <devicename>ccd0c</devicename> may not exist yet, so to
	    create it, perform the following commands:</para>

	  <programlisting>cd /dev
sh MAKEDEV ccd0</programlisting>

	  <note><para>In FreeBSD 5.0, &man.devfs.5; will automatically
	    manage device nodes in <filename>/dev</filename>, so use of
	    <command>MAKEDEV</command> is not necessary.</para></note>

	  <para>The next argument <command>ccdconfig</command> expects
	    is the interleave for the file system.  The interleave
	    defines the size of a stripe in disk blocks, normally five
	    hundred and twelve bytes.  So, an interleave of thirty-two
	    would be sixteen thousand three hundred and eighty-four
	    bytes.</para>

	  <para>After the interleave comes the flags for
	    <command>ccdconfig</command>.  If you want to enable drive
	    mirroring, you can specify a flag here.  In this
	    configuration, I am not mirroring the
	    <application>ccd</application>, so I left it as zero.</para>

	  <para>The final arguments to <command>ccdconfig</command>
	    are the devices to place into the array.  Putting it all
	    together I get this command:</para>

	  <programlisting>ccdconfig ccd0 32 0 /dev/ad1e /dev/ad2e /dev/ad3e</programlisting>

	  <para>This configures the <application>ccd</application>.
	    I can now &man.newfs.8; the file system.</para>

	  <programlisting>newfs /dev/ccd0c</programlisting>

	</sect4>

	<sect4 id="ccd-auto">
	  <title>Making it all Automatic</title>

	  <para>Finally, if I want to be able to mount the
	    <application>ccd</application>, I need to
	    configure it first.  I write out my current configuration to
	    <filename>/etc/ccd.conf</filename> using the following command:</para>

	  <programlisting>ccdconfig -g &gt; /etc/ccd.conf</programlisting>

	  <para>When I reboot, the script <command>/etc/rc</command>
	    runs <command>ccdconfig -C</command> if /etc/ccd.conf
	    exists. This automatically configures the
	    <application>ccd</application> so it can be mounted.</para>

	  <para>If you are booting into single user mode, before you can
	    <command>mount</command> the <application>ccd</application>, you
	    need to issue the following command to configure the
	    array:</para>

	  <programlisting>ccdconfig -C</programlisting>

	  <para>Then, we need an entry for the
	    <application>ccd</application> in
	    <filename>/etc/fstab</filename> so it will be mounted at
	    boot time.</para>

	  <programlisting>/dev/ccd0c              /media       ufs     rw      2       2</programlisting>
	</sect4>
      </sect3>

      <sect3 id="vinum">
	<title>The Vinum Volume Manager</title>

	<para>The Vinum Volume Manager is a block device driver which
	  implements virtual disk drives.  It isolates disk hardware
	  from the block device interface and maps data in ways which
	  result in an increase in flexibility, performance and
	  reliability compared to the traditional slice view of disk
	  storage.  &man.vinum.8; implements the RAID-0, RAID-1 and
	  RAID-5 models, both individually and in combination.</para>

	<para>See the <xref linkend="vinum-vinum"> for more
	  information about &man.vinum.8;.</para>
      </sect3>
    </sect2>

    <sect2 id="raid-hard">
      <title>Hardware RAID</title>

      <indexterm>
	<primary>RAID</primary>
	<secondary>Hardware</secondary>
      </indexterm>
      <para>FreeBSD also supports a variety of hardware <acronym>RAID</acronym>
        controllers.  In which case the actual <acronym>RAID</acronym> system
	is built and controlled by the card itself.  Using an on-card
	<acronym>BIOS</acronym>, the card will control most of the disk operations
	itself.  The following is a brief setup using a Promise <acronym>IDE RAID</acronym>
	controller.  When this card is installed and the system started up, it will
	display a prompt requesting information.  Follow the on screen instructions
	to enter the cards setup screen.  From here a user should have the ability to
	combine all the attached drives.  When doing this, the disk(s) will look like
	a single drive to FreeBSD.  Other <acronym>RAID</acronym> levels can be setup
	accordingly.
      </para>
    </sect2>
    
    <sect2>
      <title>Rebuilding ATA RAID1 Arrays</title>

      <para>FreeBSD allows you to hot-replace a failed disk in an array. This requires
	that you catch it before you reboot.</para>

      <para>You will probably see something like the following in the syslog/dmesg
	output:</para>

      <programlisting>ad6 on monster1 suffered a hard error.
ad6: READ command timeout tag=0 serv=0 - resetting
ad6: trying fallback to PIO mode
ata3: resetting devices .. done
ad6: hard error reading fsbn 1116119 of 0-7 (ad6 bn 1116119; cn 1107 tn 4 sn 11) status=59 error=40
ar0: WARNING - mirror lost</programlisting>

      <para>Using &man.atacontrol.8;, check to see how things look:</para>

      <screen>&prompt.root; <userinput>atacontrol list</userinput>
ATA channel 0:
	Master:      no device present
	Slave:   acd0 &lt;HL-DT-ST CD-ROM GCR-8520B/1.00&gt; ATA/ATAPI rev 0

ATA channel 1:
	Master:      no device present
	Slave:       no device present

ATA channel 2:
	Master:  ad4 &lt;MAXTOR 6L080J4/A93.0500&gt; ATA/ATAPI rev 5
	Slave:       no device present

ATA channel 3:
	Master:  ad6 &lt;MAXTOR 6L080J4/A93.0500&gt; ATA/ATAPI rev 5
	Slave:       no device present

&prompt.root; <userinput>atacontrol status ar0</userinput>
ar0: ATA RAID1 subdisks: ad4 ad6 status: DEGRADED</screen>

      <procedure>
	<step>
	  <para>You will first need to detach the disk from the array so that you can
	    safely remove it:</para>

	  <screen>&prompt.root; <userinput>atacontrol detach 3</userinput></screen>
	</step>

	<step>
	  <para>Replace the disk.</para>
	</step>

	<step>
	  <para>Reattach the disk as a spare:</para>

	  <screen>&prompt.root; <userinput>atacontrol attach 3</userinput>
Master:  ad6 &lt;MAXTOR 6L080J4/A93.0500&gt; ATA/ATAPI rev 5
Slave:   no device present</screen>

	<step>
	  <para>Rebuild the array:</para>

	  <screen>&prompt.root; <userinput>atacontrol rebuild ar0</userinput></screen>
	</step>

	<step>
	  <para>The rebuild command hangs until complete, its possible to open another
	    terminal and check on the progress by issuing the following command:</para>

	  <screen>&prompt.root; <userinput>dmesg | tail -10</userinput>
[output removed]
ad6: removed from configuration
ad6: deleted from ar0 disk1
ad6: inserted into ar0 disk1 as spare

&prompt.root; <userinput>atacontrol status ar0</userinput>
ar0: ATA RAID1 subdisks: ad4 ad6 status: REBUILDING 0% completed</screen>
	</step>

	<step>
	  <para>Wait until this operation completes.</para>
	</step>
      </procedure>
    </sect2>
  </sect1>
  
  <sect1 id="creating-cds">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Mike</firstname>
	  <surname>Meyer</surname>
	  <contrib>Contributed by </contrib>
	  <!-- mwm@mired.org -->
	</author>
      </authorgroup>
      <!-- Apr 2001 -->
    </sect1info>

    <title>Creating and Using Optical Media (CDs &amp; DVDs)</title>
    <indexterm>
      <primary>CDROMs</primary>
      <secondary>creating</secondary>
    </indexterm>

    <sect2>
      <title>Introduction</title>

      <para>CDs have a number of features that differentiate them from
	conventional disks. Initially, they were not writable by the
	user. They are designed so that they can be read continuously without
	delays to move the head between tracks. They are also much easier
	to transport between systems than similarly sized media were at the
	time.</para>

      <para>CDs do have tracks, but this refers to a section of data to
	be read continuously and not a physical property of the disk. To
	produce a CD on FreeBSD, you prepare the data files that are going
	to make up the tracks on the CD, then write the tracks to the
	CD.</para>

      <indexterm><primary>ISO 9660</primary></indexterm>
      <indexterm>
        <primary>file systems</primary>
        <secondary>ISO-9660</secondary>
      </indexterm>
      <para>The ISO 9660 file system was designed to deal with these
	differences. It unfortunately codifies file system limits that were
	common then. Fortunately, it provides an extension mechanism that
	allows properly written CDs to exceed those limits while still
	working with systems that do not support those extensions.</para>

      <indexterm>
        <primary><filename role="package">sysutils/mkisofs</filename></primary>
      </indexterm>
      <para>The <filename role="package">sysutils/mkisofs</filename>
	program is used to produce a data file containing an ISO 9660 file
	system. It has options that support various extensions, and is
	described below. You can install it with the
	<filename role="package">sysutils/mkisofs</filename> ports.</para>

      <indexterm>
        <primary>CD burner</primary>
        <secondary>ATAPI</secondary>
      </indexterm>
      <para>Which tool to use to burn the CD depends on whether your CD burner
	is ATAPI or something else. ATAPI CD burners use the <command><link
	linkend="burncd">burncd</link></command> program that is part of
	the base system. SCSI and USB CD burners should use
	<command><link linkend="cdrecord">cdrecord</link></command> from
	the <filename role="package">sysutils/cdrtools</filename> port.</para>

      <para><command>burncd</command> has a limited number of
	supported drives. To find out if a drive is supported, see
	<ulink url="http://freebsd.dk/ata/">CD-R/RW supported
	  drives</ulink>.</para>
    </sect2>

    <sect2 id="mkisofs">
      <title>mkisofs</title>

      <para><filename role="package">sysutils/mkisofs</filename> produces an ISO 9660 file system
	that is an image of a directory tree in the Unix file system name
	space. The simplest usage is:</para>

      <screen>&prompt.root; <userinput>mkisofs -o <replaceable>imagefile.iso</replaceable> <replaceable>/path/to/tree</replaceable></userinput></screen>

      <indexterm>
        <primary>file systems</primary>
        <secondary>ISO-9660</secondary>
      </indexterm>
      <para>This command will create an <replaceable>imagefile.iso</replaceable>
	containing an ISO 9660 file system that is a copy of the tree at
	<replaceable>/path/to/tree</replaceable>. In the process, it will
	map the file names to names that fit the limitations of the
	standard ISO 9660 file system, and will exclude files that have
	names uncharacteristic of ISO file systems.</para>
    
      <indexterm>
        <primary>file systems</primary>
        <secondary>HFS</secondary>
      </indexterm>
      <indexterm>
        <primary>file systems</primary>
        <secondary>Joliet</secondary>
      </indexterm>
      <para>A number of options are available to overcome those
	restrictions. In particular, <option>-R</option> enables the
	Rock Ridge extensions common to Unix systems, <option>-J</option>
	enables Joliet extensions used by Microsoft systems, and
	<option>-hfs</option> can be used to create HFS file systems used
	by MacOS.</para>

      <para>For CDs that are going to be used only on FreeBSD systems,
	<option>-U</option> can be used to disable all filename
	restrictions. When used with <option>-R</option>, it produces a
	file system image that is identical to the FreeBSD tree you started
	from, though it may violate the ISO 9660 standard in a number of
	ways.</para>

      <indexterm>
        <primary>CDROMs</primary>
        <secondary>creating bootable</secondary>
      </indexterm>
      <para>The last option of general use is <option>-b</option>. This is
	used to specify the location of the boot image for use in producing an
	<quote>El Torito</quote> bootable CD. This option takes an
	argument which is the path to a boot image from the top of the
	tree being written to the CD. So, given that
	<filename>/tmp/myboot</filename> holds a bootable FreeBSD system
	with the boot image in
	<filename>/tmp/myboot/boot/cdboot</filename>, you could produce the
	image of an ISO 9660 file system in
	<filename>/tmp/bootable.iso</filename> like so:</para>

      <screen>&prompt.root; <userinput>mkisofs -U -R -b boot/cdboot -o /tmp/bootable.iso /tmp/myboot</userinput></screen>

      <para>Having done that, if you have <devicename>vn</devicename>
	(FreeBSD&nbsp;4.X), or <devicename>md</devicename>
	(FreeBSD&nbsp;5.X)
	configured in your kernel, you can mount the file system with:</para>

      <screen>&prompt.root; <userinput>vnconfig -e vn0c /tmp/bootable.iso</userinput>
&prompt.root; <userinput>mount -t cd9660 /dev/vn0c /mnt</userinput></screen>

      <para>for FreeBSD&nbsp;4.X, and for FreeBSD&nbsp;5.X:</para>

      <screen>&prompt.root; <userinput>mdconfig -a -t vnode -f /tmp/bootable.iso -u 0</userinput>
&prompt.root; <userinput>mount -t cd9660 /dev/md0 /mnt</userinput></screen>

      <para>At which point you can verify that <filename>/mnt</filename>
	and <filename>/tmp/myboot</filename> are identical.</para>

      <para>There are many other options you can use with
	<filename role="package">sysutils/mkisofs</filename> to fine-tune its behavior.  In particular:
	modifications to an ISO 9660 layout and the creation of Joliet
	and HFS discs.  See the	&man.mkisofs.8; manual page for details.</para>
    </sect2>

    <sect2 id="burncd">
      <title>burncd</title>
      <indexterm>
        <primary>CDROMs</primary>
        <secondary>burning</secondary>
      </indexterm>
      <para>If you have an ATAPI CD burner, you can use the
	<command>burncd</command> command to burn an ISO image onto a
	CD. <command>burncd</command> is part of the base system, installed
	as <filename>/usr/sbin/burncd</filename>.  Usage is very simple, as
	it has few options:</para>

      <screen>&prompt.root; <userinput>burncd -f <replaceable>cddevice</replaceable> data <replaceable>imagefile.iso</replaceable> fixate</userinput></screen>

      <para>Will burn a copy of <replaceable>imagefile.iso</replaceable> on
	<replaceable>cddevice</replaceable>. The default device is
	<filename>/dev/acd0c</filename>. See &man.burncd.8; for options to
	set the write speed, eject the CD after burning, and write audio
	data.</para>
    </sect2>

    <sect2 id="cdrecord">
      <title>cdrecord</title>

      <para>If you do not have an ATAPI CD burner, you will have to use
	<command>cdrecord</command> to burn your
	CDs. <command>cdrecord</command> is not part of the base system;
	you must install it from either the port at <filename role="package">sysutils/cdrtools</filename>
	or the appropriate
	package. Changes to the base system can cause binary versions of
	this program to fail, possibly resulting in a
	<quote>coaster</quote>. You should therefore either upgrade the
	port when you upgrade your system, or if you are <link
	linkend="stable">tracking -STABLE</link>, upgrade the port when a
	new version becomes available.</para>

      <para>While <command>cdrecord</command> has many options, basic usage
	is even simpler than <command>burncd</command>. Burning an ISO 9660
	image is done with:</para>

      <screen>&prompt.root; <userinput>cdrecord dev=<replaceable>device</replaceable> <replaceable>imagefile.iso</replaceable></userinput></screen>

      <para>The tricky part of using <command>cdrecord</command> is finding
	the <option>dev</option> to use. To find the proper setting, use
	the <option>-scanbus</option> flag of <command>cdrecord</command>,
	which might produce results like this:</para>
      <indexterm>
        <primary>CDROMs</primary>
        <secondary>burning</secondary>
      </indexterm>
      <screen>&prompt.root; <userinput>cdrecord -scanbus</userinput>
Cdrecord 1.9 (i386-unknown-freebsd4.2) Copyright (C) 1995-2000 J&ouml;rg Schilling
Using libscg version 'schily-0.1'
scsibus0:
        0,0,0     0) 'SEAGATE ' 'ST39236LW       ' '0004' Disk
        0,1,0     1) 'SEAGATE ' 'ST39173W        ' '5958' Disk
        0,2,0     2) *
        0,3,0     3) 'iomega  ' 'jaz 1GB         ' 'J.86' Removable Disk
        0,4,0     4) 'NEC     ' 'CD-ROM DRIVE:466' '1.26' Removable CD-ROM
        0,5,0     5) *
        0,6,0     6) *
        0,7,0     7) *
scsibus1:
        1,0,0   100) *
        1,1,0   101) *
        1,2,0   102) *
        1,3,0   103) *
        1,4,0   104) *
        1,5,0   105) 'YAMAHA  ' 'CRW4260         ' '1.0q' Removable CD-ROM
        1,6,0   106) 'ARTEC   ' 'AM12S           ' '1.06' Scanner
        1,7,0   107) *</screen>

      <para>This lists the appropriate <option>dev</option> value for the
	devices on the list. Locate your CD burner, and use the three
	numbers separated by commas as the value for
	<option>dev</option>. In this case, the CRW device is 1,5,0, so the
	appropriate input would be
	<option>dev=1,5,0</option>. There are easier
	ways to specify this value; see &man.cdrecord.1; for
	details. That is also the place to look for information on writing
	audio tracks, controlling the speed, and other things.</para>
    </sect2>

    <sect2 id="duplicating-audiocds">
      <title>Duplicating Audio CDs</title>

      <para>You can duplicate an audio CD by extracting the audio data from
	the CD to a series of files, and then writing these files to a blank
	CD.  The process is slightly different for ATAPI and SCSI
	drives.</para>

      <procedure>
	<title>SCSI drives</title>

	<step>
	  <para>Use <command>cdda2wav</command> to extract the audio.</para>

	  <screen>&prompt.user; <userinput>cdda2wav -v255 -D2,0 -B -Owav</userinput></screen>
	</step>

	<step>
	  <para>Use <command>cdrecord</command> to write the
	    <filename>.wav</filename> files.</para>

	  <screen>&prompt.user; <userinput>cdrecord -v dev=<replaceable>2,0</replaceable> -dao -useinfo  *.wav</userinput></screen>

	  <para>Make sure that <replaceable>2.0</replaceable> is set
	    appropriately, as described in <xref linkend="cdrecord">.</para>
	</step>
      </procedure>

      <procedure>
	<title>ATAPI drives</title>

	<step>
	  <para>The ATAPI CD driver makes each track available as
	    <filename>/dev/acd<replaceable>d</replaceable>t<replaceable>n</replaceable></filename>,
	    where <replaceable>d</replaceable> is the drive number, and
	    <replaceable>n</replaceable> is the track number.  So the first
	    track on the first disk is
	    <filename>/dev/acd0t1</filename>.</para>

	  <para>Make sure the appropriate files exist in
	    <filename>/dev</filename>.</para>

	  <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV acd0t99</userinput></screen>

	  <note><para>In FreeBSD 5.0, &man.devfs.5; will automatically
	    create and manage entries in <filename>/dev</filename>
	    for you, so it is not necessary to use
	    <command>MAKEDEV</command>.</para></note>
	</step>

	<step>
	  <para>Extract each track using &man.dd.1;.  You must also use a
	    specific block size when extracting the files.</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/acd0t1 of=track1.cdr bs=2352</userinput>
&prompt.root; <userinput>dd if=/dev/acd0t2 of=track2.cdr bs=2352</userinput>
...
</screen>
	</step>

	<step>
	  <para>Burn the extracted files to disk using
	    <command>burncd</command>.  You must specify that these are audio
	    files, and that <command>burncd</command> should fixate the disk
	    when finished.</para>

	  <screen>&prompt.root; <userinput>burncd -f <replaceable>/dev/acd0c</replaceable> audio track1.cdr track2.cdr <replaceable>...</replaceable> fixate</userinput></screen>
	</step>
      </procedure>
    </sect2>

    <sect2 id="imaging-cd">
      <title>Duplicating Data CDs</title>

      <para>You can copy a data CD to a image file that is
	functionally equivalent to the image file created with
	<filename role="package">sysutils/mkisofs</filename>, and you can use it to duplicate
	any data CD.  The example given here assumes that your CDROM
	device is <devicename>acd0</devicename>.  Substitute your
	correct CDROM device.  A <literal>c</literal> must be appended
	to the end of the device name to indicate the entire partition
	or, in the case of CDROMs, the entire disc.</para>

      <screen>&prompt.root; <userinput>dd if=/dev/acd0c of=file.iso bs=2048</userinput></screen>

      <para>Now that you have an image, you can burn it to CD as
	described above.</para>
    </sect2>

    <sect2 id="mounting-cd">
      <title>Using Data CDs</title>

      <para>Now that you have created a standard data CDROM, you
	probably want to mount it and read the data on it.  By
	default, &man.mount.8; assumes that a file system is of type
	<literal>ufs</literal>.  If you try something like:</para>

      <screen>&prompt.root; <userinput>mount /dev/cd0c /mnt</userinput></screen>

      <para>you will get a complaint about <errorname>Incorrect super
	  block</errorname>, and no mount. The CDROM is not a
	  <literal>UFS</literal> file system, so attempts to mount it
	  as such will fail.  You just need to tell &man.mount.8; that
	  the file system is of type <literal>ISO9660</literal>, and
	  everything will work.  You do this by specifying the
	  <option>-t cd9660</option> option &man.mount.8;. For
	  example, if you want to mount the CDROM device,
	  <devicename>/dev/cd0c</devicename>, under
	  <filename>/mnt</filename>, you would execute:</para>

          <screen>&prompt.root; <userinput>mount -t cd9660 /dev/cd0c /mnt</userinput></screen>

      <para>Note that your device name
	(<devicename>/dev/cd0c</devicename> in this example) could be
	different, depending on the interface your CDROM uses. Also,
	the <option>-t cd9660</option> option just executes
	&man.mount.cd9660.8;. The above example could be shortened
	to:</para>

<screen>&prompt.root; <userinput>mount_cd9660 /dev/cd0c /mnt</userinput></screen>

      <para>You can generally use data CDROMs from any vendor in this
	way.  Disks with certain ISO 9660 extensions might behave
	oddly, however.  For example, Joliet disks store all filenames
	in two-byte Unicode characters.  The FreeBSD kernel does not
	speak Unicode (yet!), so non-English characters show up as
	question marks.  (If you are running FreeBSD 4.3 or later, the
	CD9660 driver includes hooks to load an appropriate Unicode
	conversion table on the fly.  Modules for some of the common
	encodings are available via the
	<filename role="package">sysutils/cd9660_unicode</filename> port.)</para>

      <para>Occasionally, you might get <errorname>Device not
	configured</errorname> when trying to mount a CDROM.  This
	usually means that the CDROM drive thinks that there is no
	disk in the tray, or that the drive is not visible on the bus.
	It can take a couple of seconds for a CDROM drive to realize
	that it has been fed, so be patient.</para>

      <para>Sometimes, a SCSI CDROM may be missed because it didn't
	have enough time to answer the bus reset.  If you have a SCSI
	CDROM please add the following option to your kernel
	configuration and <link linkend="kernelconfig-building">rebuild your kernel</link>.</para>

      <programlisting>options SCSI_DELAY=15000</programlisting>

      <para>This tells your SCSI bus to pause 15 seconds during boot,
	to give your CDROM drive every possible chance to answer the
	bus reset.</para>
    </sect2>

    <sect2 id="rawdata-cd">
      <title>Burning Raw Data CDs</title>

      <para>You can choose to burn a file directly to CD, without
	creating an ISO 9660 file system.  Some people do this for
	backup purposes.  This runs more quickly than burning a
	standard CD:</para>

      <screen>&prompt.root; <userinput>burncd -f /dev/acd1c -s 12 data archive.tar.gz fixate</userinput></screen>

      <para>In order to retrieve the data burned to such a CD, you
	  must read data from the raw device node:</para>

      <screen>&prompt.root; <userinput>tar xzvf /dev/acd1c</userinput></screen>

      <para>You cannot mount this disk as you would a normal CDROM.
	  Such a CDROM cannot be read under any operating system
	  except FreeBSD.  If you want to be able to mount the CD, or
	  share data with another operating system, you must use
	  <filename role="package">sysutils/mkisofs</filename> as described above.</para>
    </sect2>
  </sect1>
  
  <sect1 id="floppies">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Julio</firstname>
	  <surname>Merino</surname>
	  <contrib>Contributed by </contrib>
	</author>
      </authorgroup>
      <!-- 24 Dec 2001 -->
    </sect1info>

    <title>Creating and Using Floppy Disks</title>

    <para>Floppy disks are, nowadays, an old-fashioned medium to
      store/share data. Although, there are still some times when you
      need to use them, because you do not have any other removable
      storage media or you need to use what you have saved in them on
      any other computer.</para>

    <para>This section will explain how to use floppy disks in
      FreeBSD, that is, formating and copying/restoring data from
      them. But... I really have written this to help you about how to
      create forced-size floppies.</para>

    <sect2>
      <title>The device</title>

      <para>Floppy disks are accessed through entries in
        <filename>/dev</filename> (like any other device). To access the
        raw floppy disk you can use <filename>/dev/fd<replaceable>X</replaceable></filename>,
        where <replaceable>X</replaceable> stands for the drive number, usually 0. When the disk is
        formatted you can use <filename>/dev/fd<replaceable>X</replaceable></filename>, or
        whichever of the other devices named
        <filename>/dev/fd<replaceable>XY</replaceable></filename>, where <replaceable>Y</replaceable> stands for a
        letter. These are all the same.</para>

      <para>Other important devices are
        <filename>/dev/fd<replaceable>X</replaceable>.<replaceable>size</replaceable></filename>, where <replaceable>size</replaceable> is a floppy disk
        size in kilobytes. These entries are used at low-level format
        time to determine the disk size.</para>

      <para>Sometimes you will have to (re)create these entries under
        <filename>/dev</filename>. To do it, you can issue:</para>

      <screen>&prompt.root; <userinput>cd /dev && ./MAKEDEV "fd*"</userinput></screen>
      <note><para>In FreeBSD 5.0, &man.devfs.5; will automatically
	manage device nodes in <filename>/dev</filename>, so use of
	<command>MAKEDEV</command> is not necessary.</para></note>
    </sect2>

    <sect2>
      <title>Formatting</title>

      <para>A floppy disk needs to be low-level formated before it can
        be used.  This is usually done by the vendor but you may want to
        do it to check media integrity or to force the disk capacity to
        be bigger.</para>

      <para>To format the floppy at a low-level fashion you need to
        use &man.fdformat.1;. This utility expects
        the device name as an argument. We will use those
        <filename>/dev/fd<replaceable>X</replaceable>.<replaceable>size</replaceable></filename> devices, which will allow us
        to format the floppy to its real size, or force them.  So you
        insert a new 3.5inch floppy disk in your drive and issue:</para>

      <screen>&prompt.root; <userinput>/usr/sbin/fdformat /dev/fd0.1440</userinput></screen>

      <para>This will take a while... You should notice any disk error
        here (this can help you determining which disks are good or
        bad).</para>

      <para>To force the floppy disk size, we will use other entries
        in <filename>/dev</filename>.  Get the same floppy and issue:

      <screen>&prompt.root; <userinput>/usr/sbin/fdformat /dev/fd0.1720</userinput></screen>

      <para>It will take some more time than before (forced disks are
        slower).  When it finishes, you will have a 1720kB floppy disk,
        but for the moment you will not notice any difference. You may
        use other disk sizes that you can find in <filename>/dev</filename>, but the most
        stable/compatible is the 1720kB for 3.5inch disks.</para>
    </sect2>

    <sect2>
      <title>The disklabel</title>

      <para>After low-level formatting the disk, you will need to
        place a disklabel on it.  This disklabel will be destroyed
        later, but it is needed by the system to determine the size of
        the disk and its geometry later.</para>

      <para>The new disklabel will take over the whole disk, and will
        contain all the proper information about the geometry of the
        normal or forced floppy.  Take a look to
        <filename>/etc/disktab</filename> now; you will see geometry
        values of all kinds of floppy disks.

      <para>You can run now &man.disklabel.8;
        like:</para>

      <screen>&prompt.root; <userinput>/sbin/disklabel -B -r -w /dev/fd0 <replaceable>fdsize</replaceable></userinput></screen>

      <para>Replace <replaceable>fdsize</replaceable> with <literal>fd1440</literal>, <literal>fd1720</literal> or whichever size you
        want.  The last field instructs disklabel which entry to take
        from <filename>/etc/disktab</filename> to use.</para>
    </sect2>

    <sect2>
      <title>The file system</title>

      <para>Now your floppy is ready to be high-level formated. This
        will place a new file system on it, which will let FreeBSD read
        and write to the disk. After creating the new file system, the
        disklabel is destroyed, so if you want to reformat the disk, you
        will have to recreate the disklabel another time.</para>

      <para>You can choose now which file system to use on your floppy.
        You can use UFS or FAT, though UFS is not a good idea for
        floppies.  Choose FAT which is nice for floppies.</para>

      <para>To put a new file system on the floppy do this:</para>

      <screen>&prompt.root; <userinput>/sbin/newfs_msdos /dev/fd0</userinput></screen>

      <para>As we created a disklabel before, &man.newfs.8;
        will be able to fetch disk data and construct the new
        file system. And now, your disk is ready for use.</para>
    </sect2>

    <sect2>
      <title>Using the floppy</title>

      <para>You have two choices to use the floppy. You can either
        mount the disk with &man.mount.msdos.8;, or you can
        use <application>mtools</application>.
        <application>Mtools</application> are great, but you will need
        to install them from the ports system.</para>

      <para>Try it; issue a <application>mdir</application>. If you forced the
        disk, you will notice its extra size!</para>

      <para>A last note about forced disks: they are compatible with
        practically all other operating systems without any external
        utility to read/write them.  Microsoft systems will recognize
        them without problems. But note that there may be times when the
        floppy drive itself is not able to read them (this may happen
        with very old drives).</para>
    </sect2>
  </sect1>
  
  <sect1 id="backups-tapebackups">
    <title>Creating and Using Data Tapes</title>

    <indexterm><primary>tape media</primary></indexterm>
    <para>The major tape media are the 4mm, 8mm, QIC, mini-cartridge and
      DLT.</para>

    <sect2 id="backups-tapebackups-4mm">
      <title>4mm (DDS: Digital Data Storage)</title>

      <indexterm>
        <primary>tape media</primary>
	<secondary>DDS (4mm) tapes</secondary>
      </indexterm>
      <indexterm>
        <primary>tape media</primary>
	<secondary>QIC tapes</secondary>
      </indexterm>
      <para>4mm tapes are replacing QIC as the workstation backup media of
	choice.  This trend accelerated greatly when Conner purchased Archive,
	a leading manufacturer of QIC drives, and then stopped production of
	QIC drives.  4mm drives are small and quiet but do not have the
	reputation for reliability that is enjoyed by 8mm drives.  The
	cartridges are less expensive and smaller (3 x 2 x 0.5 inches, 76 x 51
	x 12 mm) than 8mm cartridges.  4mm, like 8mm, has comparatively short
	head life for the same reason, both use helical scan.</para>

      <para>Data throughput on these drives starts ~150&nbsp;kB/s, peaking at ~500&nbsp;kB/s.
	Data capacity starts at 1.3&nbsp;GB and ends at 2.0&nbsp;GB.  Hardware
	compression, available with most of these drives, approximately
	doubles the capacity.  Multi-drive tape library units can have 6
	drives in a single cabinet with automatic tape changing.  Library
	capacities reach 240&nbsp;GB.</para>

      <para>The DDS-3 standard now supports tape capacities up to 12&nbsp;GB (or
	24&nbsp;GB compressed).</para>

      <para>4mm drives, like 8mm drives, use helical-scan.  All the benefits
	and drawbacks of helical-scan apply to both 4mm and 8mm drives.</para>

      <para>Tapes should be retired from use after 2,000 passes or 100 full
	backups.</para>
    </sect2>

    <sect2 id="backups-tapebackups-8mm">
      <title>8mm (Exabyte)</title>
      <indexterm>
        <primary>tape media</primary>
	<secondary>Exabyte (8mm) tapes</secondary>
      </indexterm>

      <para>8mm tapes are the most common SCSI tape drives; they are the best
	choice of exchanging tapes.  Nearly every site has an Exabyte 2&nbsp;GB 8mm
	tape drive.  8mm drives are reliable, convenient and quiet. Cartridges
	are inexpensive and small (4.8 x 3.3 x 0.6 inches; 122 x 84 x 15 mm).
	One downside of 8mm tape is relatively short head and tape life due to
	the high rate of relative motion of the tape across the heads.</para>

      <para>Data throughput ranges from ~250&nbsp;kB/s to ~500&nbsp;kB/s.  Data sizes start
	at 300&nbsp;MB and go up to 7&nbsp;GB.  Hardware compression, available with
	most of these drives, approximately doubles the capacity.  These
	drives are available as single units or multi-drive tape libraries
	with 6 drives and 120 tapes in a single cabinet.  Tapes are changed
	automatically by the unit.  Library capacities reach 840+&nbsp;GB.</para>

      <para>The Exabyte <quote>Mammoth</quote> model supports 12&nbsp;GB on one tape
	(24&nbsp;GB with compression) and costs approximately twice as much as
	conventional tape drives.</para>

      <para>Data is recorded onto the tape using helical-scan, the heads are
	positioned at an angle to the media (approximately 6 degrees).  The
	tape wraps around 270 degrees of the spool that holds the heads.  The
	spool spins while the tape slides over the spool.  The result is a
	high density of data and closely packed tracks that angle across the
	tape from one edge to the other.</para>
    </sect2>

    <sect2 id="backups-tapebackups-qic">
      <title>QIC</title>
      <indexterm>
        <primary>tape media</primary>
	<secondary>QIC-150</secondary>
      </indexterm>

      <para>QIC-150 tapes and drives are, perhaps, the most common tape drive
	and media around.  QIC tape drives are the least expensive <quote>serious</quote>
	backup drives.  The downside is the cost of media.  QIC tapes are
	expensive compared to 8mm or 4mm tapes, up to 5 times the price per GB
	data storage.  But, if your needs can be satisfied with a half-dozen
	tapes, QIC may be the correct choice.  QIC is the
	<emphasis>most</emphasis> common tape drive.  Every site has a QIC
	drive of some density or another.  Therein lies the rub, QIC has a
	large number of densities on physically similar (sometimes identical)
	tapes.  QIC drives are not quiet.  These drives audibly seek before
	they begin to record data and are clearly audible whenever reading,
	writing or seeking.  QIC tapes measure (6 x 4 x 0.7 inches; 15.2 x
	10.2 x 1.7 mm).  <link
	  linkend="backups-tapebackups-mini">Mini-cartridges</link>, which
	also use 1/4" wide tape are discussed separately.  Tape libraries and
	changers are not available.</para>

      <para>Data throughput ranges from ~150&nbsp;kB/s to ~500&nbsp;kB/s.  Data capacity
	ranges from 40&nbsp;MB to 15&nbsp;GB.  Hardware compression is available on many
	of the newer QIC drives.  QIC drives are less frequently installed;
	they are being supplanted by DAT drives.</para>

      <para>Data is recorded onto the tape in tracks.  The tracks run along
	the long axis of the tape media from one end to the other.  The number
	of tracks, and therefore the width of a track, varies with the tape's
	capacity.  Most if not all newer drives provide backward-compatibility
	at least for reading (but often also for writing).  QIC has a good
	reputation regarding the safety of the data (the mechanics are simpler
	and more robust than for helical scan drives).</para>

      <para>Tapes should be retired from use after 5,000 backups.</para>
    </sect2>

    <sect2 id="backups-tapebackups-mini">
      <title>XXX* Mini-Cartridge</title>

      <para></para>
    </sect2>

    <sect2 id="backups-tapebackups-dlt">
      <title>DLT</title>
      <indexterm>
        <primary>tape media</primary>
	<secondary>DLT</secondary>
      </indexterm>

      <para>DLT has the fastest data transfer rate of all the drive types
	listed here.  The 1/2" (12.5mm) tape is contained in a single spool
	cartridge (4 x 4 x 1 inches; 100 x 100 x 25 mm).  The cartridge has a
	swinging gate along one entire side of the cartridge.  The drive
	mechanism opens this gate to extract the tape leader.  The tape leader
	has an oval hole in it which the drive uses to <quote>hook</quote> the tape.  The
	take-up spool is located inside the tape drive.  All the other tape
	cartridges listed here (9 track tapes are the only exception) have
	both the supply and take-up spools located inside the tape cartridge
	itself.</para>

      <para>Data throughput is approximately 1.5&nbsp;MB/s, three times the throughput of
	4mm, 8mm, or QIC tape drives.  Data capacities range from 10&nbsp;GB to 20&nbsp;GB
	for a single drive.  Drives are available in both multi-tape changers
	and multi-tape, multi-drive tape libraries containing from 5 to 900
	tapes over 1 to 20 drives, providing from 50&nbsp;GB to 9&nbsp;TB of
	storage.</para>

      <para>With compression, DLT Type IV format supports up to 70&nbsp;GB
	capacity.</para>

      <para>Data is recorded onto the tape in tracks parallel to the direction
	of travel (just like QIC tapes).  Two tracks are written at once.
	Read/write head lifetimes are relatively long; once the tape stops
	moving, there is no relative motion between the heads and the
	tape.</para>
    </sect2>

    <sect2>
      <title id="backups-tapebackups-ait">AIT</title>
      <indexterm>
        <primary>tape media</primary>
	<secondary>AIT</secondary>
      </indexterm>

      <para>AIT is a new format from Sony, and can hold up to 50&nbsp;GB (with
	compression) per tape.  The tapes contain memory chips which retain an
	index of the tape's contents.  This index can be rapidly read by the
	tape drive to determine the position of files on the tape, instead of
	the several minutes that would be required for other tapes.  Software
	such as <application>SAMS:Alexandria</application> can operate forty or more AIT tape libraries,
	communicating directly with the tape's memory chip to display the
	contents on screen, determine what files were backed up to which
	tape, locate the correct tape, load it, and restore the data from the
	tape.</para>

      <para>Libraries like this cost in the region of $20,000, pricing them a
	little out of the hobbyist market.</para>
    </sect2>

    <sect2>
      <title>Using a New Tape for the First Time</title>

      <para>The first time that you try to read or write a new, completely
	blank tape, the operation will fail.  The console messages should be
	similar to:</para>

      <screen>sa0(ncr1:4:0): NOT READY asc:4,1
sa0(ncr1:4:0):  Logical unit is in process of becoming ready</screen>

      <para>The tape does not contain an Identifier Block (block number 0).
	All QIC tape drives since the adoption of QIC-525 standard write an
	Identifier Block to the tape.  There are two solutions:</para>

      <itemizedlist>
	<listitem>
	  <para><command>mt fsf 1</command> causes the tape drive to write an
	  Identifier Block to the tape.</para>
	</listitem>

	<listitem>
	  <para>Use the front panel button to eject the tape.</para>

	  <para>Re-insert the tape and <command>dump</command> data to
	    the tape.</para>

	  <para><command>dump</command> will report <literal>DUMP: End of tape
	    detected</literal> and the console will show: <literal>HARDWARE
	    FAILURE info:280 asc:80,96</literal>.</para>

	  <para>rewind the tape using: <command>mt rewind</command>.</para>

	  <para>Subsequent tape operations are successful.</para>
	</listitem>
      </itemizedlist>

    </sect2>
  </sect1>
  
  <sect1 id="backups-floppybackups">
    <title>Backups to Floppies</title>

    <sect2 id="floppies-using">
      <title>Can I Use floppies for Backing Up My Data?</title>
      <indexterm><primary>backup floppies</primary></indexterm>
      <indexterm><primary>floppy disks</primary></indexterm>

      <para>Floppy disks are not really a suitable media for
        making backups as:</para>

      <itemizedlist>
	<listitem>
	  <para>The media is unreliable, especially over long periods of
	    time.</para>
	</listitem>

	<listitem>
	  <para>Backing up and restoring is very slow.</para>
	</listitem>

	<listitem>
	  <para>They have a very limited capacity (the days of backing up
	    an entire hard disk onto a dozen or so floppies has long since
	    passed).</para>
	</listitem>
      </itemizedlist>

      <para>However, if you have no other method of backing up your data then
	floppy disks are better than no backup at all.</para>

      <para>If you do have to use floppy disks then ensure that you use good
	quality ones. Floppies that have been lying around the office for a
	couple of years are a bad choice. Ideally use new ones from a
	reputable manufacturer.</para>
    </sect2>

    <sect2 id="floppies-creating">
      <title>So How Do I Backup My Data to Floppies?</title>

      <para>The best way to backup to floppy disk is to use
	&man.tar.1; with the <option>-M</option> (multi
	volume) option, which allows backups to span multiple
	floppies.</para>

      <para>To backup all the files in the current directory and sub-directory
	use this (as <username>root</username>):</para>

      <screen>&prompt.root; <userinput>tar Mcvf /dev/fd0 *</userinput></screen>

      <para>When the first floppy is full &man.tar.1; will prompt you to
	insert the next volume (because &man.tar.1; is media independent it
	refers to volumes; in this context it means floppy disk).</para>

      <screen>Prepare volume #2 for /dev/fd0 and hit return:</screen>

      <para>This is repeated (with the volume number incrementing) until all
	the specified files have been archived.</para>
    </sect2>

    <sect2 id="floppies-compress">
      <title>Can I Compress My Backups?</title>
      <indexterm>
        <primary><command>tar</command></primary>
      </indexterm>
      <indexterm>
        <primary><command>gzip</command></primary>
      </indexterm>
      <indexterm><primary>compression</primary></indexterm>

      <para>Unfortunately, &man.tar.1; will not allow the
	<option>-z</option> option to be used for multi-volume archives.
	You could, of course, &man.gzip.1; all the files,
	&man.tar.1; them to the floppies, then
	&man.gunzip.1; the files again!</para>
    </sect2>

    <sect2 id="floppies-restoring">
      <title>How Do I Restore My Backups?</title>

      <para>To restore the entire archive use:</para>

      <screen>&prompt.root; <userinput>tar Mxvf /dev/fd0</userinput></screen>

      <para>There are two ways that you can use to restore only
	specific files.  First, you can start with the first floppy
	and use:</para>

      <screen>&prompt.root; <userinput>tar Mxvf /dev/fd0 <replaceable>filename</replaceable></userinput></screen>

      <para>The utility &man.tar.1; will prompt you to insert subsequent floppies until it
	finds the required file.</para>

      <para>Alternatively, if you know which floppy the file is on then you
	can simply insert that floppy and use the same command as above. Note
	that if the first file on the floppy is a continuation from the
	previous one then &man.tar.1; will warn you that it cannot
	restore it, even if you have not asked it to!</para>
    </sect2>
  </sect1>

  <sect1 id="backup-basics">
    <title>Backup Basics</title>
    <indexterm><primary>backup software and basics</primary></indexterm>

    <para>The three major backup programs are
	&man.dump.8;,
	&man.tar.1;,
      and
	&man.cpio.1;.</para>

    <sect2>
      <title>Dump and Restore</title>
      <indexterm>
        <primary>backup software</primary>
	<secondary>dump / restore</secondary>
      </indexterm>
      <indexterm><primary><command>dump</command></primary></indexterm>
      <indexterm><primary><command>restore</command></primary></indexterm>

      <para>The traditional Unix backup programs are
	<command>dump</command> and <command>restore</command>.  They
	operate on the drive as a collection of disk blocks, below the
	abstractions of files, links and directories that are created by
	the file systems. <command>dump</command> backs up an entire
	file system on a device.  It is unable to backup only part of a
	file system or a directory tree that spans more than one
	file system.  <command>dump</command> does not write files and
	directories to tape, but rather writes the raw data blocks that
	comprise files and directories.</para>

      <note><para>If you use <command>dump</command> on your root directory, you
        would not back up <filename>/home</filename>,
        <filename>/usr</filename> or many other directories since
        these are typically mount points for other file systems or
        symbolic links into those file systems.</para></note>

      <para><command>dump</command> has quirks that remain from its early days in
	Version 6 of AT&amp;T Unix (circa 1975).  The default
	parameters are suitable for 9-track tapes (6250 bpi), not the
	high-density media available today (up to 62,182 ftpi).  These
	defaults must be overridden on the command line to utilize the
	capacity of current tape drives.</para>

      <indexterm><primary><filename>.rhosts</filename></primary></indexterm>
      <para>It is also possible to backup data across the network to a
        tape drive attached to another computer with <command>rdump</command> and
        <command>rrestore</command>.  Both programs rely upon <command>rcmd</command> and
        <command>ruserok</command> to access the remote tape drive.  Therefore,
	the user performing the backup must be listed in the
	<filename>.rhosts</filename> file on the remote computer.  The
        arguments to <command>rdump</command> and <command>rrestore</command> must be suitable
        to use on the remote computer.  When
        <command>rdump</command>ing from a FreeBSD computer to an
        Exabyte tape drive connected to a Sun called
        <hostid>komodo</hostid>, use:</para>

      <screen>&prompt.root; <userinput>/sbin/rdump 0dsbfu 54000 13000 126 komodo:/dev/nsa8 /dev/da0a 2>&amp;1</userinput></screen>

      <para>Beware: there are security implications to
        allowing <filename>.rhosts</filename> authentication.  Evaluate your
        situation carefully.</para>

      <para>It is also possible to use <command>dump</command> and
        <command>restore</command> in a more secure fashion over
        <command>ssh</command>.</para>

      <example>
	<title>Using <command>dump</command> over <application>ssh</application></title>

	<screen>&prompt.root; <userinput>/sbin/dump -0uan -f - /usr | gzip -2 | ssh1 -c blowfish \
          targetuser@targetmachine.example.com dd of=/mybigfiles/dump-usr-l0.gz</userinput></screen>

      </example>
    </sect2>

    <sect2>
      <title><command>tar</command></title>
      <indexterm>
        <primary>backup software</primary>
        <secondary><command>tar</command></secondary>
      </indexterm>

      <para>&man.tar.1; also dates back to Version 6 of AT&amp;T Unix
	(circa 1975).  <command>tar</command> operates in cooperation
	with the file system; <command>tar</command> writes files and
	directories to tape. <command>tar</command> does not support the
	full range of options that are available from &man.cpio.1;, but
	<command>tar</command> does not require the unusual command
	pipeline that <command>cpio</command> uses.</para>

      <indexterm><primary><command>tar</command></primary></indexterm>
      <para>Most versions of <command>tar</command> do not support
	backups across the network.  The GNU version of
	<command>tar</command>, which FreeBSD utilizes, supports remote
	devices using the same syntax as <command>rdump</command>.  To
	<command>tar</command> to an Exabyte tape drive connected to a
	Sun called <hostid>komodo</hostid>, use:</para>

      <screen>&prompt.root; <userinput>/usr/bin/tar cf komodo:/dev/nsa8 . 2>&amp;1</userinput></screen>

      <para>For versions without
	remote device support, you can use a pipeline and
	<command>rsh</command> to send the data to a remote tape
	drive.</para>

      <screen>&prompt.root; <userinput>tar cf - . | rsh <replaceable>hostname</replaceable> dd of=<replaceable>tape-device</replaceable> obs=20b</userinput></screen>

      <para>If you are worried about the security of backing up over a
	network you should use the <command>ssh</command> command
	instead of <command>rsh</command>.</para>
    </sect2>

    <sect2>
      <title><command>cpio</command></title>
      <indexterm>
        <primary>backup software</primary>
        <secondary><command>cpio</command></secondary>
      </indexterm>

      <para>&man.cpio.1; is the original Unix file interchange tape
	program for magnetic media.  <command>cpio</command> has options
	(among many others) to perform byte-swapping, write a number of
	different archive formats, and pipe the data to other programs.
	This last feature makes <command>cpio</command> and excellent
	choice for installation media.  <command>cpio</command> does not
	know how to walk the directory tree and a list of files must be
	provided through <filename>stdin</filename>.</para>
      <indexterm><primary><command>cpio</command></primary></indexterm>

      <para><command>cpio</command> does not support backups across
	the network.  You can use a pipeline and <command>rsh</command>
	to send the data to a remote tape drive.</para>

      <screen>&prompt.root; <userinput>for f in <replaceable>directory_list; do</replaceable></userinput>
<userinput>find $f >> backup.list</userinput>
<userinput>done</userinput>
&prompt.root; <userinput>cpio -v -o --format=newc < backup.list | ssh <replaceable>user</replaceable>@<replaceable>host</replaceable> "cat > <replaceable>backup_device</replaceable>"</userinput></screen>

      <para>Where <replaceable>directory_list</replaceable> is the list of
	directories you want to back up,
	<replaceable>user</replaceable>@<replaceable>host</replaceable> is the
	user/hostname combination that will be performing the backups, and
	<replaceable>backup_device</replaceable> is where the backups should
	be written to (e.g., <filename>/dev/nsa0</filename>).</para>
    </sect2>

    <sect2>
      <title><command>pax</command></title>
      <indexterm>
        <primary>backup software</primary>
        <secondary><command>pax</command></secondary>
      </indexterm>
      <indexterm><primary><command>pax</command></primary></indexterm>
      <indexterm><primary>POSIX</primary></indexterm>
      <indexterm><primary>IEEE</primary></indexterm>

      <para>&man.pax.1; is IEEE/POSIX's answer to
	<command>tar</command> and <command>cpio</command>.  Over the
	years the various versions of <command>tar</command> and
	<command>cpio</command> have gotten slightly incompatible.  So
	rather than fight it out to fully standardize them, POSIX
	created a new archive utility. <command>pax</command> attempts
	to read and write many of the various <command>cpio</command>
	and <command>tar</command> formats, plus new formats of its own.
	Its command set more resembles <command>cpio</command> than
	<command>tar</command>.</para>
    </sect2>

    <sect2 id="backups-programs-amanda">
      <title><application>Amanda</application></title>
      <indexterm>
        <primary>backup software</primary>
        <secondary><application>Amanda</application></secondary>
      </indexterm>
      <indexterm><primary><application>Amanda</application></primary></indexterm>

      <!-- Remove link until <port> tag is available -->
      <para><application>Amanda</application> (Advanced Maryland
        Network Disk Archiver) is a client/server backup system,
        rather than a single program.  An Amanda server will backup to
        a single tape drive any number of computers that have Amanda
        clients and a network connection to the Amanda server.  A
        common problem at sites with a number of large disks is
        that the length of time required to backup to data directly to tape
        exceeds the amount of time available for the task.  Amanda
        solves this problem.  Amanda can use a <quote>holding disk</quote> to
        backup several file systems at the same time.  Amanda creates
        <quote>archive sets</quote>: a group of tapes used over a period of time to
        create full backups of all the file systems listed in Amanda's
        configuration file.  The <quote>archive set</quote> also contains nightly
        incremental (or differential) backups of all the file systems.
        Restoring a damaged file system requires the most recent full
        backup and the incremental backups.</para>

      <para>The configuration file provides fine control of backups and the
	network traffic that Amanda generates.  Amanda will use any of the
	above backup programs to write the data to tape.  Amanda is available
	as either a port or a package, it is not installed by default.</para>
      </sect2>

    <sect2>
      <title>Do Nothing</title>

      <para><quote>Do nothing</quote> is not a computer program, but it is the
	most widely used backup strategy.  There are no initial costs.  There
	is no backup schedule to follow.  Just say no.  If something happens
	to your data, grin and bear it!</para>

      <para>If your time and your data is worth little to nothing, then
	<quote>Do nothing</quote> is the most suitable backup program for your
	computer.  But beware, Unix is a useful tool, you may find that within
	six months you have a collection of files that are valuable to
	you.</para>

      <para><quote>Do nothing</quote> is the correct backup method for
	<filename>/usr/obj</filename> and other directory trees that can be
	exactly recreated by your computer.  An example is the files that
	comprise the HTML or PostScript version of this Handbook.
	These document formats have been created from SGML input
	files.  Creating backups of the HTML or PostScript files is
	not necessary.  The SGML files are backed up regularly.</para>
    </sect2>

    <sect2>
      <title>Which Backup Program Is Best?</title>
      <indexterm>
        <primary>LISA</primary>
      </indexterm>

      <para>&man.dump.8; <emphasis>Period.</emphasis> Elizabeth D. Zwicky
	torture tested all the backup programs discussed here.  The clear
	choice for preserving all your data and all the peculiarities of Unix
	file systems is <command>dump</command>.  Elizabeth created file systems containing
	a large variety of unusual conditions (and some not so unusual ones)
	and tested each program by doing a backup and restore of those
	file systems.  The peculiarities included: files with holes, files with
	holes and a block of nulls, files with funny characters in their
	names, unreadable and unwritable files, devices, files that change
	size during the backup, files that are created/deleted during the
	backup and more.  She presented the results at LISA V in Oct. 1991.
	See <ulink
	  url="http://reality.sgi.com/zwicky_neu/testdump.doc.html">torture-testing
	  Backup and Archive Programs</ulink>.</para>
    </sect2>

    <sect2>
      <title>Emergency Restore Procedure</title>

      <sect3>
	<title>Before the Disaster</title>

	<para>There are only four steps that you need to perform in
	  preparation for any disaster that may occur.</para>
	<indexterm>
    <primary><command>disklabel</command></primary>
  </indexterm>

	<para>First, print the disklabel from each of your disks
	  (e.g. <command>disklabel da0 | lpr</command>), your file system table
	  (<filename>/etc/fstab</filename>) and all boot messages,
	  two copies of
	  each.</para>

	<indexterm><primary>fix-it floppies</primary></indexterm>
	<para>Second, determine that the boot and fix-it floppies
	  (<filename>boot.flp</filename> and <filename>fixit.flp</filename>)
	  have all your devices.  The easiest way to check is to reboot your
	  machine with the boot floppy in the floppy drive and check the boot
	  messages.  If all your devices are listed and functional, skip on to
	  step three.</para>

	<para>Otherwise, you have to create two custom bootable
	  floppies which have a kernel that can mount all of your disks
	  and access your tape drive.  These floppies must contain:
	  <command>fdisk</command>, <command>disklabel</command>,
	  <command>newfs</command>, <command>mount</command>, and
	  whichever backup program you use.  These programs must be
	  statically linked.  If you use <command>dump</command>, the
	  floppy must contain <command>restore</command>.</para>

	<para>Third, create backup tapes regularly.  Any changes that you make
	  after your last backup may be irretrievably lost.  Write-protect the
	  backup tapes.</para>

	<para>Fourth, test the floppies (either <filename>boot.flp</filename>
	  and <filename>fixit.flp</filename> or the two custom bootable
	  floppies you made in step two.) and backup tapes.  Make notes of the
	  procedure.  Store these notes with the bootable floppy, the
	  printouts and the backup tapes.  You will be so distraught when
	  restoring that the notes may prevent you from destroying your backup
	  tapes (How? In place of <command>tar xvf /dev/sa0</command>, you
	  might accidentally type <command>tar cvf /dev/sa0</command> and
	  over-write your backup tape).</para>

	<para>For an added measure of security, make bootable floppies and two
	  backup tapes each time.  Store one of each at a remote location.  A
	  remote location is NOT the basement of the same office building.  A
	  number of firms in the World Trade Center learned this lesson the
	  hard way.  A remote location should be physically separated from
	  your computers and disk drives by a significant distance.</para>

	<example>
	  <title>A Script for Creating a Bootable Floppy</title>

	<programlisting><![ CDATA [#!/bin/sh
#
# create a restore floppy
#
# format the floppy
#
PATH=/bin:/sbin:/usr/sbin:/usr/bin

fdformat -q fd0
if [ $? -ne 0 ]
then
	 echo "Bad floppy, please use a new one"
	 exit 1
fi

# place boot blocks on the floppy
#
disklabel -w -B /dev/fd0c fd1440

#
# newfs the one and only partition
#
newfs -t 2 -u 18 -l 1 -c 40 -i 5120 -m 5 -o space /dev/fd0a

#
# mount the new floppy
#
mount /dev/fd0a /mnt

#
# create required directories
#
mkdir /mnt/dev
mkdir /mnt/bin
mkdir /mnt/sbin
mkdir /mnt/etc
mkdir /mnt/root
mkdir /mnt/mnt			# for the root partition
mkdir /mnt/tmp
mkdir /mnt/var

#
# populate the directories
#
if [ ! -x /sys/compile/MINI/kernel ]
then
	 cat << EOM
The MINI kernel does not exist, please create one.
Here is an example config file:
#
# MINI -- A kernel to get FreeBSD onto a disk.
#
machine         "i386"
cpu             "I486_CPU"
ident           MINI
maxusers        5

options         INET                    # needed for _tcp _icmpstat _ipstat
                                        #            _udpstat _tcpstat _udb
options         FFS                     #Berkeley Fast File System
options         FAT_CURSOR              #block cursor in syscons or pccons
options         SCSI_DELAY=15           #Be pessimistic about Joe SCSI device
options         NCONS=2                 #1 virtual consoles
options         USERCONFIG              #Allow user configuration with -c XXX

config          kernel	root on da0 swap on da0 and da1 dumps on da0

device          isa0
device          pci0

device          fdc0	at isa? port "IO_FD1" bio irq 6 drq 2 vector fdintr
device          fd0	at fdc0 drive 0

device          ncr0

device          scbus0

device          sc0	at isa? port "IO_KBD" tty irq 1 vector scintr
device          npx0	at isa? port "IO_NPX" irq 13 vector npxintr

device          da0
device          da1
device          da2

device          sa0

pseudo-device   loop            # required by INET
pseudo-device   gzip            # Exec gzipped a.out's
EOM
	 exit 1
fi

cp -f /sys/compile/MINI/kernel /mnt

gzip -c -best /sbin/init > /mnt/sbin/init
gzip -c -best /sbin/fsck > /mnt/sbin/fsck
gzip -c -best /sbin/mount > /mnt/sbin/mount
gzip -c -best /sbin/halt > /mnt/sbin/halt
gzip -c -best /sbin/restore > /mnt/sbin/restore

gzip -c -best /bin/sh > /mnt/bin/sh
gzip -c -best /bin/sync > /mnt/bin/sync

cp /root/.profile /mnt/root

cp -f /dev/MAKEDEV /mnt/dev
chmod 755 /mnt/dev/MAKEDEV

chmod 500 /mnt/sbin/init
chmod 555 /mnt/sbin/fsck /mnt/sbin/mount /mnt/sbin/halt
chmod 555 /mnt/bin/sh /mnt/bin/sync
chmod 6555 /mnt/sbin/restore

#
# create the devices nodes
#
cd /mnt/dev
./MAKEDEV std
./MAKEDEV da0
./MAKEDEV da1
./MAKEDEV da2
./MAKEDEV sa0
./MAKEDEV pty0
cd /

#
# create minimum file system table
#
cat > /mnt/etc/fstab <<EOM
/dev/fd0a    /    ufs    rw  1  1
EOM

#
# create minimum passwd file
#
cat > /mnt/etc/passwd <<EOM
root:*:0:0:Charlie &:/root:/bin/sh
EOM

cat > /mnt/etc/master.passwd <<EOM
root::0:0::0:0:Charlie &:/root:/bin/sh
EOM

chmod 600 /mnt/etc/master.passwd
chmod 644 /mnt/etc/passwd
/usr/sbin/pwd_mkdb -d/mnt/etc /mnt/etc/master.passwd

#
# umount the floppy and inform the user
#
/sbin/umount /mnt
echo "The floppy has been unmounted and is now ready."]]></programlisting>

        </example>

      </sect3>

      <sect3>
	<title>After the Disaster</title>

	<para>The key question is: did your hardware survive?  You have been
	  doing regular backups so there is no need to worry about the
	  software.</para>

	<para>If the hardware has been damaged.  First, replace those parts
	  that have been damaged.</para>

	<para>If your hardware is okay, check your floppies.  If you are using
	  a custom boot floppy, boot single-user (type <literal>-s</literal>
	  at the <prompt>boot:</prompt> prompt).  Skip the following
	  paragraph.</para>

	<para>If you are using the <filename>boot.flp</filename> and
	  <filename>fixit.flp</filename> floppies, keep reading.  Insert the
	  <filename>boot.flp</filename> floppy in the first floppy drive and
	  boot the computer.  The original install menu will be displayed on
	  the screen.  Select the <literal>Fixit--Repair mode with CDROM or
	    floppy.</literal> option.  Insert the
	  <filename>fixit.flp</filename> when prompted.
	  <command>restore</command> and the other programs that you need are
	  located in <filename>/mnt2/stand</filename>.</para>

	<para>Recover each file system separately.</para>

	<indexterm>
    <primary><command>mount</command></primary>
  </indexterm>	    
	<indexterm><primary>root partition</primary></indexterm>
	<indexterm>
    <primary><command>disklabel</command></primary>
  </indexterm>
	<indexterm>
    <primary><command>newfs</command></primary>
  </indexterm> 
	<para>Try to <command>mount</command> (e.g. <command>mount /dev/da0a
	    /mnt</command>)  the root partition of your first disk.  If the
	  disklabel was damaged, use <command>disklabel</command> to re-partition and
	  label the disk to match the label that you printed and saved.  Use
	    <command>newfs</command> to re-create the file systems.  Re-mount the root
	  partition of the floppy read-write (<command>mount -u -o rw
	    /mnt</command>).  Use your backup program and backup tapes to
	  recover the data for this file system (e.g. <command>restore vrf
	    /dev/sa0</command>).  Unmount the file system (e.g. <command>umount
	    /mnt</command>) Repeat for each file system that was
	  damaged.</para>

	<para>Once your system is running, backup your data onto new tapes.
	  Whatever caused the crash or data loss may strike again.  Another
	  hour spent now may save you from further distress later.</para>
      </sect3>

<![ %not.published; [

      <sect3>
	<title>* I did not prepare for the Disaster, What Now?</title>

	<para></para>
      </sect3>
]]>

    </sect2>
  </sect1>

  <sect1 id="disks-virtual">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Marc</firstname>
	  <surname>Fonvieille</surname>
	  <contrib>Reorganized and enhanced by </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Network, Memory, and File-Backed File Systems</title>
    <indexterm><primary>virtual disks</primary></indexterm>
    <indexterm>
      <primary>disks</primary>
      <secondary>virtual</secondary>
    </indexterm>

    <para>Aside from the disks you physically insert into your computer:
      floppies, CDs, hard drives, and so forth; other forms of disks
      are understood by FreeBSD - the <firstterm>virtual
      disks</firstterm>.</para>

    <indexterm><primary>NFS</primary></indexterm>
    <indexterm><primary>Coda</primary></indexterm>
    <indexterm>
      <primary>disks</primary>
      <secondary>memory</secondary>
    </indexterm>
    <para>These include network file systems such as the <link
	linkend="nfs">Network File System</link> and Coda, memory-based
      file systems and
      file-backed file systems.</para>

    <para>According to the FreeBSD version you run, you will have to use
      different tools for creation and use of file-backed and
      memory-based file systems.</para>

    <note>
      <para>The FreeBSD&nbsp;4.X users will have to use &man.MAKEDEV.8;
	to create the required devices.  FreeBSD&nbsp;5.0 and later use
	&man.devfs.5; to allocate device nodes transparently for the
	user.</para>
    </note>

    <sect2 id="disks-vnconfig">
      <title>File-Backed File System under FreeBSD&nbsp;4.X</title>
      <indexterm>
        <primary>disks</primary>
        <secondary>file-backed under FreeBSD&nbsp;4.X</secondary>
      </indexterm>

      <para>The utility &man.vnconfig.8; configures and enables vnode pseudo-disk
	devices.  A <firstterm>vnode</firstterm> is a representation
	of a file, and is the focus of file activity.  This means that
	&man.vnconfig.8; uses files to create and operate a
	file system.  One possible use is the mounting of floppy or CD
	images kept in files.</para>

      <para>To use &man.vnconfig.8;, you need &man.vn.4; support in your
	kernel configuration file:</para>

      <programlisting>pseudo-device vn</programlisting>

      <para>To mount an existing file system image:</para>

      <example>
	<title>Using vnconfig to mount an Existing File System
	  Image under FreeBSD&nbsp;4.X</title>

	<screen>&prompt.root; <userinput>vnconfig vn<replaceable>0</replaceable> <replaceable>diskimage</replaceable></userinput>
&prompt.root; <userinput>mount /dev/vn<replaceable>0</replaceable>c <replaceable>/mnt</replaceable></userinput></screen>
      </example>

      <para>To create a new file system image with &man.vnconfig.8;:</para>

      <example>
	<title>Creating a New File-Backed Disk with <command>vnconfig</command></title>
	
	<screen>&prompt.root; <userinput>dd if=/dev/zero of=<replaceable>newimage</replaceable> bs=1k count=<replaceable>5</replaceable>k</userinput>
5120+0 records in
5120+0 records out
&prompt.root; <userinput>vnconfig -s labels -c vn<replaceable>0</replaceable> <replaceable>newimage</replaceable></userinput>
&prompt.root; <userinput>disklabel -r -w vn<replaceable>0</replaceable> auto</userinput>
&prompt.root; <userinput>newfs vn<replaceable>0</replaceable>c</userinput>
Warning: 2048 sector(s) in last cylinder unallocated
/dev/vn0c:     10240 sectors in 3 cylinders of 1 tracks, 4096 sectors
        5.0MB in 1 cyl groups (16 c/g, 32.00MB/g, 1280 i/g)
super-block backups (for fsck -b #) at:
 32
&prompt.root; <userinput>mount /dev/vn<replaceable>0</replaceable>c <replaceable>/mnt</replaceable></userinput>
&prompt.root; <userinput>df <replaceable>/mnt</replaceable></userinput>
Filesystem  1K-blocks     Used    Avail Capacity  Mounted on
/dev/vn0c        4927        1     4532     0%    /mnt</screen>
      </example>
    </sect2>

    <sect2 id="disks-mdconfig">
      <title>File-Backed File System under FreeBSD&nbsp;5.X</title>
      <indexterm>
        <primary>disks</primary>
        <secondary>file-backed under FreeBSD&nbsp;5.X</secondary>
      </indexterm>

      <para>The utility &man.mdconfig.8; is used to configure and enable
	memory disks, &man.md.4;, under FreeBSD&nbsp;5.X.  To use
	&man.mdconfig.8;, you have to load &man.md.4; module or to add
	the support in your kernel configuration file:</para>

      <programlisting>device md</programlisting>

      <para>The &man.mdconfig.8; command supports three kinds of
	memory backed virtual disks: memory disks allocated with
	&man.malloc.9;, memory disks using a file or swapspace as
	backingstore.  One possible use is the mounting of floppy
	or CD images kept in files.</para>

      <para>To mount an existing file system image:</para>

      <example>
	<title>Using <command>mdconfig</command> to mount an Existing File System
	  Image under FreeBSD&nbsp;5.X</title>

	<screen>&prompt.root; <userinput>mdconfig -a -t vnode -f <replaceable>diskimage</replaceable> -u <replaceable>0</replaceable></userinput>
&prompt.root; <userinput>mount /dev/md<replaceable>0</replaceable>c <replaceable>/mnt</replaceable></userinput></screen>
      </example>

      <para>To create a new file system image with &man.mdconfig.8;:</para>

      <example>
	<title>Creating a New File-Backed Disk with <command>mdconfig</command></title>
	
	<screen>&prompt.root; <userinput>dd if=/dev/zero of=<replaceable>newimage</replaceable> bs=1k count=<replaceable>5</replaceable>k</userinput>
5120+0 records in
5120+0 records out
&prompt.root; <userinput>mdconfig -a -t vnode -f <replaceable>newimage</replaceable> -u <replaceable>0</replaceable></userinput>
&prompt.root; <userinput>disklabel -r -w md<replaceable>0</replaceable> auto</userinput>
&prompt.root; <userinput>newfs md<replaceable>0</replaceable>c</userinput>
/dev/md0c: 5.0MB (10240 sectors) block size 16384, fragment size 2048
	using 4 cylinder groups of 1.27MB, 81 blks, 256 inodes.
super-block backups (for fsck -b #) at:
 32, 2624, 5216, 7808
&prompt.root; <userinput>mount /dev/md<replaceable>0</replaceable>c <replaceable>/mnt</replaceable></userinput>
&prompt.root; <userinput>df <replaceable>/mnt</replaceable></userinput>
Filesystem  1K-blocks     Used    Avail Capacity  Mounted on
/dev/md0c        4846        2     4458     0%    /mnt</screen>
      </example>

      <para>If you do not specify the unit number with the
	<option>-u</option> option, &man.mdconfig.8; will use the
	&man.md.4; automatic allocation to select an unused device.
	The name of the allocated unit will be output on stdout like
	<devicename>md4</devicename>.  For more details about
	&man.mdconfig.8;, please refer to the manual page.</para>

      <para>The utility &man.mdconfig.8; is very useful, however it
	asks many command lines to create a file-backed file system.
	FreeBSD&nbsp;5.0 also comes with a tool called &man.mdmfs.8;,
	this program configures a &man.md.4; disk using
	&man.mdconfig.8;, puts a UFS file system on it using
	&man.newfs.8;, and mounts it using &man.mount.8;.  For example,
	if you want to create and mount the same file system image as
	above, simply type the following:</para>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=<replaceable>newimage</replaceable> bs=1k count=<replaceable>5</replaceable>k</userinput>
5120+0 records in
5120+0 records in
5120+0 records out
&prompt.root; <userinput>mdmfs -F <replaceable>newimage</replaceable> -s <replaceable>5</replaceable>m md<replaceable>0</replaceable> <replaceable>/mnt</replaceable></userinput>
&prompt.root; <userinput>df <replaceable>/mnt</replaceable></userinput>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md0        4846    2  4458     0%    /mnt</screen>

      <para>If you use the option <option>md</option> without unit
	number, &man.mdmfs.8; will use &man.md.4; auto-unit feature to
	automatically select an unused device.  For more details
	about &man.mdmfs.8;, please refer to the manual page.</para>

    </sect2>

    <sect2 id="disks-md-freebsd4">
      <title>Memory-Based File System under FreeBSD&nbsp;4.X</title>
      <indexterm>
        <primary>disks</primary>
        <secondary>memory file system under FreeBSD&nbsp;4.X</secondary>
      </indexterm>

      <para>The &man.md.4; driver is a simple, efficient means to create memory
	file systems under FreeBSD&nbsp;4.X. &man.malloc.9; is used
	to allocate the memory.</para>

      <para>Simply take a file system you have prepared with, for
	example, &man.vnconfig.8;, and:</para>

      <example>
	<title>md Memory Disk under FreeBSD&nbsp;4.X</title>

	<screen>&prompt.root; <userinput>dd if=<replaceable>newimage</replaceable> of=/dev/md<replaceable>0</replaceable></userinput>
5120+0 records in
5120+0 records out
&prompt.root; <userinput>mount /dev/md<replaceable>0c</replaceable> <replaceable>/mnt</replaceable></userinput>
&prompt.root; <userinput>df <replaceable>/mnt</replaceable></userinput>
Filesystem  1K-blocks     Used    Avail Capacity  Mounted on
/dev/md0c        4927        1     4532     0%    /mnt</screen>
      </example>

      <para>For more details, please refer to &man.md.4; manual
	page.</para>

    <sect2 id="disks-md-freebsd5">
      <title>Memory-Based File System under FreeBSD&nbsp;5.X</title>
      <indexterm>
        <primary>disks</primary>
        <secondary>memory file system under FreeBSD&nbsp;5.X</secondary>
      </indexterm>

      <para>The same tools are used for memory-based and file-backed
	file systems: &man.mdconfig.8; or &man.mdmfs.8;.  The storage
	for memory-based file system is allocated with
	&man.malloc.9;.</para>

      <example>
	<title>Creating a New Memory-Based Disk with
	  <command>mdconfig</command></title>

	<screen>&prompt.root; <userinput>mdconfig -a -t malloc -s <replaceable>5</replaceable>m -u <replaceable>1</replaceable></userinput>
&prompt.root; <userinput>newfs -U md<replaceable>1</replaceable></userinput>
/dev/md1: 5.0MB (10240 sectors) block size 16384, fragment size 2048
	using 4 cylinder groups of 1.27MB, 81 blks, 256 inodes.
	with soft updates
super-block backups (for fsck -b #) at:
 32, 2624, 5216, 7808
&prompt.root; <userinput>mount /dev/md<replaceable>1</replaceable> <replaceable>/mnt</replaceable></userinput>
&prompt.root; <userinput>df <replaceable>/mnt</replaceable></userinput>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md1        4846    2  4458     0%    /mnt</screen>
      </example>

      <example>
	<title>Creating a New Memory-Based Disk with
	  <command>mdmfs</command></title>
	<screen>&prompt.root; <userinput>mdmfs -M -s <replaceable>5</replaceable>m md<replaceable>2</replaceable> <replaceable>/mnt</replaceable></userinput>
&prompt.root; <userinput>df <replaceable>/mnt</replaceable></userinput>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md2        4846    2  4458     0%    /mnt</screen>
      </example>

      <para>Instead of using a &man.malloc.9; backed file system, it is
	possible to use swap, for that just replace
	<option>malloc</option> with <option>swap</option> in the
	command line of &man.mdconfig.8;.  The &man.mdmfs.8; utility
	by default (without <option>-M</option>) creates a swap-based
	disk.  For more details, please refer to &man.mdconfig.8;
	and &man.mdmfs.8; manual pages.</para>
    </sect2>

    <sect2>
      <title>Detaching a Memory Disk from the System</title>
      <indexterm>
        <primary>disks</primary>
        <secondary>detaching a memory disk</secondary>
      </indexterm>

      <para>When a memory-based or file-based file system
	is not used, you should release all resources to the system.
	The first thing to do is to unmount the file system, then use
	&man.mdconfig.8; to detach the disk from the system and release
	the resources.</para>

      <para>For example to detach and free all resources used by
	<filename>/dev/md4</filename>:</para>

      <screen>&prompt.root; <userinput>mdconfig -d -u <replaceable>4</replaceable></userinput></screen>

      <para>It is possible to list information about configured
	&man.md.4; devices in using the command <command>mdconfig
	-l</command>.</para>

      <para>For FreeBSD&nbsp;4.X, &man.vnconfig.8; is used to detach
	the device.  For example to detach and free all resources
	used by <filename>/dev/vn4</filename>:</para>

      <screen>&prompt.root; <userinput>vnconfig -u vn<replaceable>4</replaceable></userinput></screen>


    </sect2>
  </sect1>
  
  <sect1 id="snapshots">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Contributed by </contrib>
	</author>
      </authorgroup>
      <!-- 15 JUL 2002 -->
    </sect1info>

    <title>File System Snapshots</title>

    <indexterm>
      <primary>File System Snapshots</primary>
      <secondary>Snapshots</secondary>
    </indexterm>
    
      <para>FreeBSD&nbsp;5.0 offers a new feature in conjunction with
	<link linkend="soft-updates">Soft Updates</link>: File system snapshots.</para>

      <para>Snapshots allow a user to create images of specified file
	systems, and treat them as a file.
	Snapshot files must be created in the file system that the
	action is performed on, and a user may create no more than 20
	snapshots per file system.  Active snapshots are recorded
	in the superblock so they are persistent across unmount and
	remount operations along with system reboots.  When a snapshot
	is no longer required, it can be removed with the standard &man.rm.1;
	command.  Snapshots may be removed in any order,
	however all the used space may not be acquired because another snapshot will
	possibly claim some of the released blocks.</para>

      <para>During initial creation, the <option>schg</option> flag (see the &man.chflags.1; manual page)
	is set to ensure that even <username>root</username> cannot write to the snapshot.
	The &man.unlink.1; command makes an exception for snapshot files
	since it allows them to be removed
	with the <option>schg</option> flag set, so it is not necessary to
	clear the <option>schg</option> flag before removing a snapshot file.</para>

      <para>Snapshots are created with the &man.mount.8; command.  To place
	a snapshot of <filename>/var</filename> in the file
	<filename>/var/snapshot/snap</filename> use the following
	command:</para>

<screen>&prompt.root; <userinput>mount -u -o snapshot /var/snapshot/snap /var</userinput></screen>

      <para>Once a snapshot has been created, they have several
	uses:</para>

      <itemizedlist>
	<listitem>
	  <para>Some administrators will use a snapshot file for backup purposes,
	    because the snapshot can be transfered to CDs or tape.</para>
	</listitem>
	
	<listitem>
	  <para>File integrity, &man.fsck.8; may be ran on the snapshot.
	    Assuming that the file system was clean when it was mounted, you
	    should always get a clean (and unchanging) result.
	    This is essentially what the
	    background &man.fsck.8; process does.</para>
	</listitem>
	
	<listitem>
	  <para>Run the &man.dump.8; utility on the snapshot.
	    A dump will be returned that is consistent with the
	    file system and the timestamp of the snapshot.  &man.dump.8;
	    can also take a snapshot, create a dump image and then
	    remove the snapshot in one command using the
	    <option>-L</option> flag.</para>
	</listitem>
	
	<listitem>
	  <para>&man.mount.8; the snapshot as a frozen image of the file system.
	    To &man.mount.8; the snapshot
	    <filename>/var/snapshot/snap</filename> run:</para>

<screen>&prompt.root; <userinput>mdconfig -a -t vnode -f /var/snapshot/snap -u 4</userinput></screen>
<screen>&prompt.root; <userinput>mount -r /dev/md4 /mnt</userinput></screen>

	</listitem>
      </itemizedlist>

      <para>You can now walk the hierarchy of your frozen <filename>/var</filename>
	file system mounted at <filename>/mnt</filename>.  Everything will
	be in the same state it was during the snapshot creation time.
	The only exception is that any earlier snapshots will appear
	as zero length files.  When the use of a snapshot has delimited,
	it can be unmounted with:</para>

<screen>&prompt.root; <userinput>umount /mnt</userinput></screen>
<screen>&prompt.root; <userinput>mdconfig -d -u 4</userinput></screen>

      <para>For more information about <option>softupdates</option> and
	file system snapshots, including technical papers, you can visit
	Marshall Kirk McKusick's website at
	<ulink url="http://www.mckusick.com/">http://www.mckusick.com.</ulink></para>
  </sect1>
  
  <sect1 id="quotas">
    <title>檔案系統配額</title>
    <indexterm>
      <primary>accounting</primary>
      <secondary>disk space</secondary>
    </indexterm>
    <indexterm><primary>disk quotas</primary></indexterm>

    <para>磁碟配額是一種作業系統選用的功能，您可以利用它來限制某使用者，
      或是某群組在系統裡可以使用的磁碟空間大小 和/或 檔案的數量。
      這個功能控用在分時多工系統上，因為分時多工系統要限定每個使用者，
      或是某個群組所能使用的系統資源。
      會這樣做是為了避免磁碟空間被某個使用者給耗盡了。</para>

    <sect2>
      <title>設定您的系統以便使用磁碟配額</title>

      <para>在使用磁碟配額之前您要先確定是否已經在系統核心中做好設定了。
        您只要在您的系統核心設定檔中加入下面這行：</para>

      <programlisting>options QUOTA</programlisting>

      <para>通用系統核心設定 <filename>GENERIC</filename>
        的預設值並沒有這一項，所以如果您想使用磁碟配額的話，
        您就必須自己設定，建立，並安裝您的自定系統核心。
        請參考 <link linkend="kernelconfig">設定 FreeBSD 核心</link>
        一節以獲得更多有關設定系統核心的資訊。</para>

      <para>下一步就是在
        <filename>/etc/rc.conf</filename> 啟動磁碟配額的功能。
        您只要把下面這一行：</para>
      <programlisting>enable_quotas="YES"</programlisting>
      <indexterm>
        <primary>disk quotas</primary>
        <secondary>checking</secondary>
      </indexterm>
      <para>為了在啟動磁碟配額時能得到出色的控管，
        這邊有一個附加的設定值可供修改。當系統正常啟動時，
        磁碟配額這個功能將會使用 &man.quotacheck.8;
        這個程式來對每一個檔案系統作完整的檢查。
        &man.quotacheck.8;
        這個程式將會促進確保在磁碟配額資料庫中的資料，
        能正確的反映在檔案系統上。
        但是這個功能也會在啟動您的系統時，對啟動完成時間有相當大程度的影響。
        假如您想跳過這個步驟，下面這個變數是可供您變動的：</para>

      <programlisting>check_quotas="NO"</programlisting>

      <para>如果您使用的是 FreeBSD 3.2-RELEASE 較早的版本，
        您也可以將這唯一的設定值設到 <filename>/etc/rc.conf</filename> 中：
        </para>

      <programlisting>check_quotas="YES"</programlisting>

      <para>最後，您必須以檔案系統為單位在 <filename>/etc/fstab</filename>
        裡啟動磁碟配額的功能。
        您可以在那個檔案裡面為您所有的檔案系統啟動使用者，
        群組，或是兩者的磁碟配額。</para>

      <para>如果您想要啟動的是使用者磁碟配額，您只要在
        <filename>/etc/fstab</filename> 中選定您所要設定的檔案系統，
        並把 <literal>userquota</literal> 這個選項加到該檔案系統的 options
        欄位中。例如：</para>

      <programlisting>/dev/da1s2g   /home    ufs rw,userquota 1 2</programlisting>

      <para>同理，把 <literal>userquota</literal> 換成
        <literal>groupquota</literal> 就可以啟動群組磁碟配額的功能。
        如果您兩種磁碟配額都想啟動的話，您只要把那一行改成：</para>

      <programlisting>/dev/da1s2g    /home    ufs rw,userquota,groupquota 1 2</programlisting>

      <para>內定的磁碟配額記錄檔是放在該檔案系統的根目錄下，名字是
        <filename>quota.user</filename> 以及
        <filename>quota.group</filename>，
        分別是使用者磁碟配額以及群組磁碟配額的記錄檔。
        您可以參考 <command>man fstab</command> 以得到更多資訊。
        雖然 man page 說您可以把記錄檔放在其他地方，
        但是我們並不建議您這麼做，
        因為並非所有跟磁碟配額相關的程式都能夠正確地處理這項功能。</para>

      <para>接下來您就必須用您的新核心來重開機了。因為
        <filename>/etc/rc</filename> 會自動執行適當的指令來為您在
        <filename>/etc/fstab</filename>
        中所啟動的磁碟配額功能建立初始化的磁碟配額記錄檔，
        所以您並不需要自己手動建立一個空的磁碟配額記錄檔。</para>

      <para>在一般的操作過程中您並不需要手動去執行
        &man.quotacheck.8;、&man.quotaon.8;、
        或是 &man.quotaoff.8; 這些程式。
        不過或許您也可以讀讀它們的 manual pages
        以熟悉它們的操作方式。</para>
    </sect2>

    <sect2>
      <title>>設定磁碟配額的上限</title>
      <indexterm>
        <primary>disk quotas</primary>
        <secondary>limits</secondary>
      </indexterm>

      <para>一旦您為系統加上了磁碟配額的功能後，請確認它們是否已正常啟動。
        執行下列這個指令是一個簡單的檢查方法：</para>

      <screen>&prompt.root; <userinput>quota -v</userinput></screen>
	  
      <para>每個啟動了磁碟配額的檔案系統都會有一行關於磁碟使用量，
        以及目前上限設定值的摘要。</para>

      <para>您現在可以開始用 &man.edquota.8;
        指令來指定磁碟配額上限了。</para>

      <para>您有很多選項可以用來限制使用者或群組所能分配到的磁碟空間，
        以及他們能夠建立的檔案數量。您可以依磁碟空間 (block 配額) ，
        或是檔案數量(inode 配額) ，或是結合這兩種配額來設定使用上限。
        每一種上限的設定都可以更進一步分成兩類：強制型 (hard) ，
        以及非強制型 (soft) 上限。</para>

      <indexterm><primary>hard limit</primary></indexterm>
      <para>強制型上限是不能超過的。
        一旦使用者的使用量到達他們的強制型上限設定時，
        他們就無法在這個檔案系統上再要求配置磁碟了。
        舉例來說，如果有個使用者的強制型上限是 500 blocks，而他目前已經用掉
        490 的 blocks 了；如此一來，這個使用者只能再要求配置 10
        blocks。如果他想要求配置 11 個 blocks 則會失敗。</para>

      <indexterm><primary>soft limit</primary></indexterm>
      <para>另一方面，非強制型上限可以容許某段時間之內的超用；
        這段時間稱為 grace period，預設值是一個星期。
        如果使用者超用非強制型上限的時間超過了這個 grace period
        的話，則非強制型上限就會轉為強制型上限而不允許該使用者再配置任何磁碟，
        直到使用者所使用的磁碟量小於非強制型上限後，這個 grace period
        才會被重新設定。</para>

      <para>下面是一個執行 &man.edquota.8; 指令的例子。當您執行
        &man.edquota.8; 指令時，
        您會進入一個編輯磁碟配額上限的編輯器內，
        至於是什麼編輯器則視您的 <envar>EDITOR</envar> 環境變數而定；
        如果沒有設定 <envar>EDITOR</envar> 這個環境變數則使用
        <application>vi</application> 。</para>

      <screen>&prompt.root; <userinput>edquota -u test</userinput></screen>

      <programlisting>Quotas for user test:
/usr: blocks in use: 65, limits (soft = 50, hard = 75)
        inodes in use: 7, limits (soft = 50, hard = 60)
/usr/var: blocks in use: 0, limits (soft = 50, hard = 75)
        inodes in use: 0, limits (soft = 50, hard = 60)</programlisting>

      <para>一般來說，每個啟動了磁碟配額的檔案系統都會有兩行設定。
        一行是用來指定 block 上限，而另一行則是用來指定 inode 上限。
        如果您想要變更磁碟配額上限，只需要修改後面的數值即可。舉例來說，
        如果您想要調升這個使用者的 block 上限，把非強制型上限由 50 改到
        500，把強制型上限由 75 改到 600，您只要把這一行變更為：</para>

      <programlisting>/usr: blocks in use: 65, limits (soft = 50, hard = 75)</programlisting>

      <para>to:</para>

      <programlisting> /usr: blocks in use: 65, limits (soft = 500, hard = 600)</programlisting>

      <para>當您離開編輯器後，新的磁碟配額設定就會馬上生效。</para>

      <para>有的時候我們會想要為某一個範圍內的 uid 一起設定磁碟配額。
        我們可以用 &man.edquota.8; 的 <option>-p</option>
        選項來完成這個工作。首先，我們先為某一個使用者設定磁碟配額；
        接著就執行<command>edquota -p protouser startuid-enduid</command>。
        舉例來說，假設使用者 test 已經設定好磁碟配額，
        您就可以利用下面這個指令來為 uid 在 10000 到 19999
        的使用者來設定跟使用者 test 一樣的磁碟配額：</para>

      <screen>&prompt.root; <userinput>edquota -p test 10000-19999</userinput></screen>
	  
      <para>參閱 &man.edquota.8; 以得到更詳盡的資訊。</para>
    </sect2>

    <sect2>
      <title>檢查磁碟配額的設定及磁碟使用的狀況</title>
      <indexterm>
        <primary>disk quotas</primary>
        <secondary>checking</secondary>
      </indexterm>

      <para>您可以使用 &man.quota.1; 或是
        &man.repquota.8;
        指令來檢查磁碟配額的設定及磁碟使用的狀況。
        &man.quota.1; 指令可以用來檢查個別使用者，
        以及群組的磁碟配額，以及磁碟使用量。
        只有超級使用者才能檢查其他使用者的磁碟配額以及磁碟使用量，
        或是檢查非您所屬群組的磁碟配額及磁碟使用量。
        &man.repquota.8;
        指令可以看到有啟動磁碟配額功能的檔案系統的磁碟配額設定，
        以及磁碟使用量的使用摘要。</para>

      <para>下面是一個在兩個檔案系統有磁碟配額設定的使用者
        <command>quota -v</command> 指令的輸出情形：</para>

      <programlisting>Disk quotas for user test (uid 1002):
     Filesystem  blocks   quota   limit   grace   files   quota   limit   grace
           /usr      65*     50      75   5days       7      50      60
       /usr/var       0      50      75               0      50      60</programlisting>

      <indexterm><primary>grace period</primary></indexterm>
      <para>上例中，這個使用者在 <filename>/usr</filename>
        檔案系統中的非強制性磁碟配額是 50 blocks,他的使用超出了 15
        blocks，而 grace period 還有 5 天。注意這個星號<literal>*</literal>
        是表示目前這名使用者已經超過他的非強制性上限了。</para>

      <para>一般來說如果使用者沒有使用到某個檔案系統，
        則就算該檔案系統已經啟動了磁碟配額功能，它也不會在
        <command>quota</command> 指令中顯現出來。而 <option>-v</option>
        這個選項則可以把這些檔案系統全部顯示出來，如上例中的
        <filename>/usr/var</filename> 。</para>
    </sect2>

    <sect2>
      <title>Quotas over NFS</title>
      <indexterm><primary>NFS</primary></indexterm>

      <para>Quotas are enforced by the quota subsystem on the NFS server.
	The &man.rpc.rquotad.8; daemon makes quota information available
	to the &man.quota.1; command on NFS clients, allowing users on
	those machines to see their quota statistics.</para>

      <para>Enable <command>rpc.rquotad</command> in
	<filename>/etc/inetd.conf</filename> like so:</para>

      <programlisting>rquotad/1      dgram rpc/udp wait root /usr/libexec/rpc.rquotad rpc.rquotad</programlisting>

      <para>Now restart <command>inetd</command>:</para>

      <screen>&prompt.root; <userinput>kill -HUP `cat /var/run/inetd.pid`</userinput></screen>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
